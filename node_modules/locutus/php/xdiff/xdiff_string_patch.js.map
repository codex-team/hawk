{"version":3,"sources":["../../../src/php/xdiff/xdiff_string_patch.js"],"names":["module","exports","xdiff_string_patch","originalStr","patch","flags","errorObj","_getNativeFlags","regex","global","ignoreCase","multiline","extended","sticky","join","_cbSplit","string","sep","RegExp","String","prototype","split","apply","arguments","str","output","lastLastIndex","match","lastLength","limit","Infinity","x","_xregexp","s","source","captureNames","slice","exec","lastIndex","push","index","length","Array","test","i","ll","ranges","lastLinePos","firstChar","rangeExp","lineBreaks","lines","replace","origLines","newStrArr","linePos","errors","optTemp","OPTS","concat","XDIFF_PATCH_NORMAL","charAt","Error","XDIFF_PATCH_REVERSE","value"],"mappings":"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","file":"xdiff_string_patch.js","sourcesContent":["module.exports = function xdiff_string_patch (originalStr, patch, flags, errorObj) { // eslint-disable-line camelcase\n  //  discuss at: http://locutus.io/php/xdiff_string_patch/\n  // original by: Brett Zamir (http://brett-zamir.me)\n  // improved by: Steven Levithan (stevenlevithan.com)\n  //      note 1: The XDIFF_PATCH_IGNORESPACE flag and the error argument are not\n  //      note 1: currently supported.\n  //      note 2: This has not been tested exhaustively yet.\n  //      note 3: The errorObj parameter (optional) if used must be passed in as a\n  //      note 3: object. The errors will then be written by reference into it's `value` property\n  //   example 1: xdiff_string_patch('', '@@ -0,0 +1,1 @@\\n+Hello world!')\n  //   returns 1: 'Hello world!'\n\n  // First two functions were adapted from Steven Levithan, also under an MIT license\n  // Adapted from XRegExp 1.5.0\n  // (c) 2007-2010 Steven Levithan\n  // MIT License\n  // <http://xregexp.com>\n\n  var _getNativeFlags = function (regex) {\n    // Proposed for ES4; included in AS3\n    return [\n      (regex.global ? 'g' : ''),\n      (regex.ignoreCase ? 'i' : ''),\n      (regex.multiline ? 'm' : ''),\n      (regex.extended ? 'x' : ''),\n      (regex.sticky ? 'y' : '')\n    ].join('')\n  }\n\n  var _cbSplit = function (string, sep) {\n    // If separator `s` is not a regex, use the native `split`\n    if (!(sep instanceof RegExp)) {\n      // Had problems to get it to work here using prototype test\n      return String.prototype.split.apply(string, arguments)\n    }\n    var str = String(string)\n    var output = []\n    var lastLastIndex = 0\n    var match\n    var lastLength\n    var limit = Infinity\n    var x = sep._xregexp\n    // This is required if not `s.global`, and it avoids needing to set `s.lastIndex` to zero\n    // and restore it to its original value when we're done using the regex\n    // Brett paring down\n    var s = new RegExp(sep.source, _getNativeFlags(sep) + 'g')\n    if (x) {\n      s._xregexp = {\n        source: x.source,\n        captureNames: x.captureNames ? x.captureNames.slice(0) : null\n      }\n    }\n\n    while ((match = s.exec(str))) {\n      // Run the altered `exec` (required for `lastIndex` fix, etc.)\n      if (s.lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index))\n\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1))\n        }\n\n        lastLength = match[0].length\n        lastLastIndex = s.lastIndex\n\n        if (output.length >= limit) {\n          break\n        }\n      }\n\n      if (s.lastIndex === match.index) {\n        s.lastIndex++\n      }\n    }\n\n    if (lastLastIndex === str.length) {\n      if (!s.test('') || lastLength) {\n        output.push('')\n      }\n    } else {\n      output.push(str.slice(lastLastIndex))\n    }\n\n    return output.length > limit ? output.slice(0, limit) : output\n  }\n\n  var i = 0\n  var ll = 0\n  var ranges = []\n  var lastLinePos = 0\n  var firstChar = ''\n  var rangeExp = /^@@\\s+-(\\d+),(\\d+)\\s+\\+(\\d+),(\\d+)\\s+@@$/\n  var lineBreaks = /\\r?\\n/\n  var lines = _cbSplit(patch.replace(/(\\r?\\n)+$/, ''), lineBreaks)\n  var origLines = _cbSplit(originalStr, lineBreaks)\n  var newStrArr = []\n  var linePos = 0\n  var errors = ''\n  var optTemp = 0 // Both string & integer (constant) input is allowed\n  var OPTS = {\n    // Unsure of actual PHP values, so better to rely on string\n    'XDIFF_PATCH_NORMAL': 1,\n    'XDIFF_PATCH_REVERSE': 2,\n    'XDIFF_PATCH_IGNORESPACE': 4\n  }\n\n  // Input defaulting & sanitation\n  if (typeof originalStr !== 'string' || !patch) {\n    return false\n  }\n  if (!flags) {\n    flags = 'XDIFF_PATCH_NORMAL'\n  }\n\n  if (typeof flags !== 'number') {\n    // Allow for a single string or an array of string flags\n    flags = [].concat(flags)\n    for (i = 0; i < flags.length; i++) {\n      // Resolve string input to bitwise e.g. 'XDIFF_PATCH_NORMAL' becomes 1\n      if (OPTS[flags[i]]) {\n        optTemp = optTemp | OPTS[flags[i]]\n      }\n    }\n    flags = optTemp\n  }\n\n  if (flags & OPTS.XDIFF_PATCH_NORMAL) {\n    for (i = 0, ll = lines.length; i < ll; i++) {\n      ranges = lines[i].match(rangeExp)\n      if (ranges) {\n        lastLinePos = linePos\n        linePos = ranges[1] - 1\n        while (lastLinePos < linePos) {\n          newStrArr[newStrArr.length] = origLines[lastLinePos++]\n        }\n        while (lines[++i] && (rangeExp.exec(lines[i])) === null) {\n          firstChar = lines[i].charAt(0)\n          switch (firstChar) {\n            case '-':\n            // Skip including that line\n              ++linePos\n              break\n            case '+':\n              newStrArr[newStrArr.length] = lines[i].slice(1)\n              break\n            case ' ':\n              newStrArr[newStrArr.length] = origLines[linePos++]\n              break\n            default:\n            // Reconcile with returning errrors arg?\n              throw new Error('Unrecognized initial character in unidiff line')\n          }\n        }\n        if (lines[i]) {\n          i--\n        }\n      }\n    }\n    while (linePos > 0 && linePos < origLines.length) {\n      newStrArr[newStrArr.length] = origLines[linePos++]\n    }\n  } else if (flags & OPTS.XDIFF_PATCH_REVERSE) {\n    // Only differs from above by a few lines\n    for (i = 0, ll = lines.length; i < ll; i++) {\n      ranges = lines[i].match(rangeExp)\n      if (ranges) {\n        lastLinePos = linePos\n        linePos = ranges[3] - 1\n        while (lastLinePos < linePos) {\n          newStrArr[newStrArr.length] = origLines[lastLinePos++]\n        }\n        while (lines[++i] && (rangeExp.exec(lines[i])) === null) {\n          firstChar = lines[i].charAt(0)\n          switch (firstChar) {\n            case '-':\n              newStrArr[newStrArr.length] = lines[i].slice(1)\n              break\n            case '+':\n            // Skip including that line\n              ++linePos\n              break\n            case ' ':\n              newStrArr[newStrArr.length] = origLines[linePos++]\n              break\n            default:\n            // Reconcile with returning errrors arg?\n              throw new Error('Unrecognized initial character in unidiff line')\n          }\n        }\n        if (lines[i]) {\n          i--\n        }\n      }\n    }\n    while (linePos > 0 && linePos < origLines.length) {\n      newStrArr[newStrArr.length] = origLines[linePos++]\n    }\n  }\n\n  if (errorObj) {\n    errorObj.value = errors\n  }\n\n  return newStrArr.join('\\n')\n}\n"]}