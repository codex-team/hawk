{"version":3,"sources":["../../../src/php/_locutus_shared/_locutus_shared_bc.js"],"names":[],"mappings":"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","file":"_locutus_shared_bc.js","sourcesContent":["module.exports = function _locutus_shared_bc () { // eslint-disable-line camelcase\n  //  discuss at: http://locutusjs.io/php/_locutus_shared/_locutus_shared_bc\n  // original by: lmeyrick (https://sourceforge.net/projects/bcmath-js/)\n  // improved by: Brett Zamir (http://brett-zamir.me)\n  //   example 1: var $bc = _locutus_shared_bc()\n  //   example 1: var $result = $bc.PLUS\n  //   returns 1: '+'\n\n  /**\n   * BC Math Library for Javascript\n   * Ported from the PHP5 bcmath extension source code,\n   * which uses the Libbcmath package...\n   *    Copyright (C) 1991, 1992, 1993, 1994, 1997 Free Software Foundation, Inc.\n   *    Copyright (C) 2000 Philip A. Nelson\n   *     The Free Software Foundation, Inc.\n   *     59 Temple Place, Suite 330\n   *     Boston, MA 02111-1307 USA.\n   *      e-mail:  philnelson@acm.org\n   *     us-mail:  Philip A. Nelson\n   *               Computer Science Department, 9062\n   *               Western Washington University\n   *               Bellingham, WA 98226-9062\n   *\n   * bcmath-js homepage:\n   *\n   * This code is covered under the LGPL licence, and can be used however you want :)\n   * Be kind and share any decent code changes.\n   */\n\n  /**\n   * Binary Calculator (BC) Arbitrary Precision Mathematics Lib v0.10  (LGPL)\n   * Copy of Libbcmath included in PHP5 src\n   *\n   * Note: this is just the shared library file and does not include the php-style functions.\n   *       use bcmath{-min}.js for functions like bcadd, bcsub etc.\n   *\n   * Feel free to use how-ever you want, just email any bug-fixes/improvements\n   * to the sourceforge project:\n   *\n   *\n   * Ported from the PHP5 bcmath extension source code,\n   * which uses the Libbcmath package...\n   *    Copyright (C) 1991, 1992, 1993, 1994, 1997 Free Software Foundation, Inc.\n   *    Copyright (C) 2000 Philip A. Nelson\n   *     The Free Software Foundation, Inc.\n   *     59 Temple Place, Suite 330\n   *     Boston, MA 02111-1307 USA.\n   *      e-mail:  philnelson@acm.org\n   *     us-mail:  Philip A. Nelson\n   *               Computer Science Department, 9062\n   *               Western Washington University\n   *               Bellingham, WA 98226-9062\n   */\n\n  var Libbcmath = {\n    PLUS: '+',\n    MINUS: '-',\n    BASE: 10,\n    // must be 10 (for now)\n    scale: 0,\n    // default scale\n    /**\n     * Basic number structure\n     */\n    bc_num: function () {\n      this.n_sign = null // sign\n      this.n_len = null // (int) The number of digits before the decimal point.\n      this.n_scale = null // (int) The number of digits after the decimal point.\n        // this.n_refs = null; // (int) The number of pointers to this number.\n        // this.n_text = null; // ?? Linked list for available list.\n      this.n_value = null // array as value, where 1.23 = [1,2,3]\n      this.toString = function () {\n        var r, tmp\n        tmp = this.n_value.join('')\n\n        // add minus sign (if applicable) then add the integer part\n        r = ((this.n_sign === Libbcmath.PLUS) ? '' : this.n_sign) + tmp.substr(0, this.n_len)\n\n        // if decimal places, add a . and the decimal part\n        if (this.n_scale > 0) {\n          r += '.' + tmp.substr(this.n_len, this.n_scale)\n        }\n        return r\n      }\n    },\n\n    /**\n     * Base add function\n     *\n     //  Here is the full add routine that takes care of negative numbers.\n     //  N1 is added to N2 and the result placed into RESULT.  SCALE_MIN\n     //  is the minimum scale for the result.\n     *\n     * @param {bc_num} n1\n     * @param {bc_num} n2\n     * @param {int} scaleMin\n     * @return bc_num\n     */\n    bc_add: function (n1, n2, scaleMin) {\n      var sum, cmpRes, resScale\n\n      if (n1.n_sign === n2.n_sign) {\n        sum = Libbcmath._bc_do_add(n1, n2, scaleMin)\n        sum.n_sign = n1.n_sign\n      } else { // subtraction must be done.\n        cmpRes = Libbcmath._bc_do_compare(n1, n2, false, false) // Compare magnitudes.\n        switch (cmpRes) {\n          case -1:\n            // n1 is less than n2, subtract n1 from n2.\n            sum = Libbcmath._bc_do_sub(n2, n1, scaleMin)\n            sum.n_sign = n2.n_sign\n            break\n\n          case 0:\n            // They are equal! return zero with the correct scale!\n            resScale = Libbcmath.MAX(scaleMin, Libbcmath.MAX(n1.n_scale, n2.n_scale))\n            sum = Libbcmath.bc_new_num(1, resScale)\n            Libbcmath.memset(sum.n_value, 0, 0, resScale + 1)\n            break\n\n          case 1:\n            // n2 is less than n1, subtract n2 from n1.\n            sum = Libbcmath._bc_do_sub(n1, n2, scaleMin)\n            sum.n_sign = n1.n_sign\n        }\n      }\n      return sum\n    },\n\n    /**\n     * This is the \"user callable\" routine to compare numbers N1 and N2.\n     * @param {bc_num} n1\n     * @param {bc_num} n2\n     * @return int -1, 0, 1  (n1 < n2, ===, n1 > n2)\n     */\n    bc_compare: function (n1, n2) {\n      return Libbcmath._bc_do_compare(n1, n2, true, false)\n    },\n\n    _one_mult: function (num, nPtr, size, digit, result, rPtr) {\n      var carry, value // int\n      var nptr, rptr // int pointers\n      if (digit === 0) {\n        Libbcmath.memset(result, 0, 0, size) // memset (result, 0, size);\n      } else {\n        if (digit === 1) {\n          Libbcmath.memcpy(result, rPtr, num, nPtr, size) // memcpy (result, num, size);\n        } else { // Initialize\n          nptr = nPtr + size - 1 // nptr = (unsigned char *) (num+size-1);\n          rptr = rPtr + size - 1 // rptr = (unsigned char *) (result+size-1);\n          carry = 0\n\n          while (size-- > 0) {\n            value = num[nptr--] * digit + carry // value = *nptr-- * digit + carry;\n            result[rptr--] = value % Libbcmath.BASE // @CHECK cint //*rptr-- = value % BASE;\n            carry = Math.floor(value / Libbcmath.BASE) // @CHECK cint //carry = value / BASE;\n          }\n\n          if (carry !== 0) {\n            result[rptr] = carry\n          }\n        }\n      }\n    },\n\n    bc_divide: function (n1, n2, scale) {\n      // var quot // bc_num return\n      var qval // bc_num\n      var num1, num2 // string\n      var ptr1, ptr2, n2ptr, qptr // int pointers\n      var scale1, val // int\n      var len1, len2, scale2, qdigits, extra, count // int\n      var qdig, qguess, borrow, carry // int\n      var mval // string\n      var zero // char\n      var norm // int\n      // var ptrs // return object from one_mul\n      // Test for divide by zero. (return failure)\n      if (Libbcmath.bc_is_zero(n2)) {\n        return -1\n      }\n\n      // Test for zero divide by anything (return zero)\n      if (Libbcmath.bc_is_zero(n1)) {\n        return Libbcmath.bc_new_num(1, scale)\n      }\n\n      /* Test for n1 equals n2 (return 1 as n1 nor n2 are zero)\n        if (Libbcmath.bc_compare(n1, n2, Libbcmath.MAX(n1.n_scale, n2.n_scale)) === 0) {\n          quot=Libbcmath.bc_new_num(1, scale);\n          quot.n_value[0] = 1;\n          return quot;\n        }\n      */\n\n      // Test for divide by 1.  If it is we must truncate.\n      // @todo: check where scale > 0 too.. can't see why not\n      // (ie bc_is_zero - add bc_is_one function)\n      if (n2.n_scale === 0) {\n        if (n2.n_len === 1 && n2.n_value[0] === 1) {\n          qval = Libbcmath.bc_new_num(n1.n_len, scale) // qval = bc_new_num (n1->n_len, scale);\n          qval.n_sign = (n1.n_sign === n2.n_sign ? Libbcmath.PLUS : Libbcmath.MINUS)\n          // memset (&qval->n_value[n1->n_len],0,scale):\n          Libbcmath.memset(qval.n_value, n1.n_len, 0, scale)\n          // memcpy (qval->n_value, n1->n_value, n1->n_len + MIN(n1->n_scale,scale)):\n          Libbcmath.memcpy(\n            qval.n_value, 0, n1.n_value, 0, n1.n_len + Libbcmath.MIN(n1.n_scale, scale)\n          )\n          // can we return here? not in c src, but can't see why-not.\n          // return qval;\n        }\n      }\n\n      /* Set up the divide.  Move the decimal point on n1 by n2's scale.\n       Remember, zeros on the end of num2 are wasted effort for dividing. */\n      scale2 = n2.n_scale // scale2 = n2->n_scale;\n      n2ptr = n2.n_len + scale2 - 1 // n2ptr = (unsigned char *) n2.n_value+n2.n_len+scale2-1;\n      while ((scale2 > 0) && (n2.n_value[n2ptr--] === 0)) {\n        scale2--\n      }\n\n      len1 = n1.n_len + scale2\n      scale1 = n1.n_scale - scale2\n      if (scale1 < scale) {\n        extra = scale - scale1\n      } else {\n        extra = 0\n      }\n\n      // num1 = (unsigned char *) safe_emalloc (1, n1.n_len+n1.n_scale, extra+2):\n      num1 = Libbcmath.safe_emalloc(1, n1.n_len + n1.n_scale, extra + 2)\n      if (num1 === null) {\n        Libbcmath.bc_out_of_memory()\n      }\n      // memset (num1, 0, n1->n_len+n1->n_scale+extra+2):\n      Libbcmath.memset(num1, 0, 0, n1.n_len + n1.n_scale + extra + 2)\n      // memcpy (num1+1, n1.n_value, n1.n_len+n1.n_scale):\n      Libbcmath.memcpy(num1, 1, n1.n_value, 0, n1.n_len + n1.n_scale)\n      // len2 = n2->n_len + scale2:\n      len2 = n2.n_len + scale2\n      // num2 = (unsigned char *) safe_emalloc (1, len2, 1):\n      num2 = Libbcmath.safe_emalloc(1, len2, 1)\n      if (num2 === null) {\n        Libbcmath.bc_out_of_memory()\n      }\n      // memcpy (num2, n2.n_value, len2):\n      Libbcmath.memcpy(num2, 0, n2.n_value, 0, len2)\n      // *(num2+len2) = 0:\n      num2[len2] = 0\n      // n2ptr = num2:\n      n2ptr = 0\n      // while (*n2ptr === 0):\n      while (num2[n2ptr] === 0) {\n        n2ptr++\n        len2--\n      }\n\n      // Calculate the number of quotient digits.\n      if (len2 > len1 + scale) {\n        qdigits = scale + 1\n        zero = true\n      } else {\n        zero = false\n        if (len2 > len1) {\n          qdigits = scale + 1 // One for the zero integer part.\n        } else {\n          qdigits = len1 - len2 + scale + 1\n        }\n      }\n\n      // Allocate and zero the storage for the quotient.\n      // qval = bc_new_num (qdigits-scale,scale);\n      qval = Libbcmath.bc_new_num(qdigits - scale, scale)\n      // memset (qval->n_value, 0, qdigits);\n      Libbcmath.memset(qval.n_value, 0, 0, qdigits)\n        // Allocate storage for the temporary storage mval.\n      // mval = (unsigned char *) safe_emalloc (1, len2, 1);\n      mval = Libbcmath.safe_emalloc(1, len2, 1)\n      if (mval === null) {\n        Libbcmath.bc_out_of_memory()\n      }\n\n      // Now for the full divide algorithm.\n      if (!zero) { // Normalize\n        // norm = Libbcmath.cint(10 / (Libbcmath.cint(n2.n_value[n2ptr]) + 1));\n        // norm =  10 / ((int)*n2ptr + 1)\n        norm = Math.floor(10 / (n2.n_value[n2ptr] + 1)) // norm =  10 / ((int)*n2ptr + 1);\n        if (norm !== 1) {\n          // Libbcmath._one_mult(num1, len1+scale1+extra+1, norm, num1);\n          Libbcmath._one_mult(num1, 0, len1 + scale1 + extra + 1, norm, num1, 0)\n          // Libbcmath._one_mult(n2ptr, len2, norm, n2ptr);\n          Libbcmath._one_mult(n2.n_value, n2ptr, len2, norm, n2.n_value, n2ptr)\n          // @todo: Check: Is the pointer affected by the call? if so,\n          // maybe need to adjust points on return?\n        }\n\n        // Initialize divide loop.\n        qdig = 0\n        if (len2 > len1) {\n          qptr = len2 - len1 // qptr = (unsigned char *) qval.n_value+len2-len1;\n        } else {\n          qptr = 0 // qptr = (unsigned char *) qval.n_value;\n        }\n\n        // Loop\n        while (qdig <= len1 + scale - len2) { // Calculate the quotient digit guess.\n          if (n2.n_value[n2ptr] === num1[qdig]) {\n            qguess = 9\n          } else {\n            qguess = Math.floor((num1[qdig] * 10 + num1[qdig + 1]) / n2.n_value[n2ptr])\n          }\n          // Test qguess.\n\n          if (n2.n_value[n2ptr + 1] * qguess >\n            (num1[qdig] * 10 + num1[qdig + 1] - n2.n_value[n2ptr] * qguess) *\n            10 + num1[qdig + 2]) {\n            qguess--\n            // And again.\n            if (n2.n_value[n2ptr + 1] * qguess >\n              (num1[qdig] * 10 + num1[qdig + 1] - n2.n_value[n2ptr] * qguess) *\n              10 + num1[qdig + 2]) {\n              qguess--\n            }\n          }\n\n          // Multiply and subtract.\n          borrow = 0\n          if (qguess !== 0) {\n            mval[0] = 0 //* mval = 0; // @CHECK is this to fix ptr2 < 0?\n            // _one_mult (n2ptr, len2, qguess, mval+1); // @CHECK\n            Libbcmath._one_mult(n2.n_value, n2ptr, len2, qguess, mval, 1)\n            ptr1 = qdig + len2 // (unsigned char *) num1+qdig+len2;\n            ptr2 = len2 // (unsigned char *) mval+len2;\n            // @todo: CHECK: Does a negative pointer return null?\n            // ptr2 can be < 0 here as ptr1 = len2, thus count < len2+1 will always fail ?\n            for (count = 0; count < len2 + 1; count++) {\n              if (ptr2 < 0) {\n                // val = Libbcmath.cint(num1[ptr1]) - 0 - borrow;\n                // val = (int) *ptr1 - (int) *ptr2-- - borrow;\n                val = num1[ptr1] - 0 - borrow // val = (int) *ptr1 - (int) *ptr2-- - borrow;\n              } else {\n                // val = Libbcmath.cint(num1[ptr1]) - Libbcmath.cint(mval[ptr2--]) - borrow;\n                // val = (int) *ptr1 - (int) *ptr2-- - borrow;\n                // val = (int) *ptr1 - (int) *ptr2-- - borrow;\n                val = num1[ptr1] - mval[ptr2--] - borrow\n              }\n              if (val < 0) {\n                val += 10\n                borrow = 1\n              } else {\n                borrow = 0\n              }\n              num1[ptr1--] = val\n            }\n          }\n\n          // Test for negative result.\n          if (borrow === 1) {\n            qguess--\n            ptr1 = qdig + len2 // (unsigned char *) num1+qdig+len2;\n            ptr2 = len2 - 1 // (unsigned char *) n2ptr+len2-1;\n            carry = 0\n            for (count = 0; count < len2; count++) {\n              if (ptr2 < 0) {\n                // val = Libbcmath.cint(num1[ptr1]) + 0 + carry;\n                // val = (int) *ptr1 + (int) *ptr2-- + carry;\n                // val = (int) *ptr1 + (int) *ptr2-- + carry;\n                val = num1[ptr1] + 0 + carry\n              } else {\n                // val = Libbcmath.cint(num1[ptr1]) + Libbcmath.cint(n2.n_value[ptr2--]) + carry;\n                // val = (int) *ptr1 + (int) *ptr2-- + carry;\n                // val = (int) *ptr1 + (int) *ptr2-- + carry;\n                val = num1[ptr1] + n2.n_value[ptr2--] + carry\n              }\n              if (val > 9) {\n                val -= 10\n                carry = 1\n              } else {\n                carry = 0\n              }\n              num1[ptr1--] = val //* ptr1-- = val;\n            }\n            if (carry === 1) {\n              // num1[ptr1] = Libbcmath.cint((num1[ptr1] + 1) % 10);\n              // *ptr1 = (*ptr1 + 1) % 10; // @CHECK\n              // *ptr1 = (*ptr1 + 1) % 10; // @CHECK\n              num1[ptr1] = (num1[ptr1] + 1) % 10\n            }\n          }\n\n          // We now know the quotient digit.\n          qval.n_value[qptr++] = qguess //* qptr++ =  qguess;\n          qdig++\n        }\n      }\n\n      // Clean up and return the number.\n      qval.n_sign = (n1.n_sign === n2.n_sign ? Libbcmath.PLUS : Libbcmath.MINUS)\n      if (Libbcmath.bc_is_zero(qval)) {\n        qval.n_sign = Libbcmath.PLUS\n      }\n      Libbcmath._bc_rm_leading_zeros(qval)\n\n      return qval\n\n      // return 0;    // Everything is OK.\n    },\n\n    MUL_BASE_DIGITS: 80,\n    MUL_SMALL_DIGITS: (80 / 4),\n    // #define MUL_SMALL_DIGITS mul_base_digits/4\n\n    /* The multiply routine.  N2 times N1 is put int PROD with the scale of\n   the result being MIN(N2 scale+N1 scale, MAX (SCALE, N2 scale, N1 scale)).\n   */\n    /**\n     * @param n1 bc_num\n     * @param n2 bc_num\n     * @param scale [int] optional\n     */\n    bc_multiply: function (n1, n2, scale) {\n      var pval // bc_num\n      var len1, len2 // int\n      var fullScale, prodScale // int\n        // Initialize things.\n      len1 = n1.n_len + n1.n_scale\n      len2 = n2.n_len + n2.n_scale\n      fullScale = n1.n_scale + n2.n_scale\n      prodScale = Libbcmath.MIN(\n        fullScale, Libbcmath.MAX(scale, Libbcmath.MAX(n1.n_scale, n2.n_scale))\n      )\n\n      // pval = Libbcmath.bc_init_num(); // allow pass by ref\n      // Do the multiply\n      pval = Libbcmath._bc_rec_mul(n1, len1, n2, len2, fullScale)\n\n      // Assign to prod and clean up the number.\n      pval.n_sign = (n1.n_sign === n2.n_sign ? Libbcmath.PLUS : Libbcmath.MINUS)\n        // pval.n_value = pval.nPtr; // @todo: pval.n_len = len2 + len1 + 1 - fullScale\n      pval.n_scale = prodScale\n      Libbcmath._bc_rm_leading_zeros(pval)\n      if (Libbcmath.bc_is_zero(pval)) {\n        pval.n_sign = Libbcmath.PLUS\n      }\n      // bc_free_num (prod);\n      return pval\n    },\n\n    new_sub_num: function (length, scale, value) {\n      var temp = new Libbcmath.bc_num() // eslint-disable-line new-cap\n      temp.n_sign = Libbcmath.PLUS\n      temp.n_len = length\n      temp.n_scale = scale\n      temp.n_value = value\n      return temp\n    },\n\n    _bc_simp_mul: function (n1, n1len, n2, n2len, fullScale) {\n      var prod // bc_num\n      var n1ptr, n2ptr, pvptr // char *n1ptr, *n2ptr, *pvptr;\n      var n1end, n2end // char *n1end, *n2end;        // To the end of n1 and n2.\n      var indx, sum, prodlen // int indx, sum, prodlen;\n      prodlen = n1len + n2len + 1\n\n      prod = Libbcmath.bc_new_num(prodlen, 0)\n\n      n1end = n1len - 1 // (char *) (n1->n_value + n1len - 1);\n      n2end = n2len - 1 // (char *) (n2->n_value + n2len - 1);\n      pvptr = prodlen - 1 // (char *) ((*prod)->n_value + prodlen - 1);\n      sum = 0\n\n      // Here is the loop...\n      for (indx = 0; indx < prodlen - 1; indx++) {\n        // (char *) (n1end - MAX(0, indx-n2len+1));\n        n1ptr = n1end - Libbcmath.MAX(0, indx - n2len + 1)\n        // (char *) (n2end - MIN(indx, n2len-1));\n        n2ptr = n2end - Libbcmath.MIN(indx, n2len - 1)\n        while ((n1ptr >= 0) && (n2ptr <= n2end)) {\n          // sum += *n1ptr-- * *n2ptr++;\n          sum += n1.n_value[n1ptr--] * n2.n_value[n2ptr++]\n        }\n        //* pvptr-- = sum % BASE;\n        prod.n_value[pvptr--] = Math.floor(sum % Libbcmath.BASE)\n        sum = Math.floor(sum / Libbcmath.BASE) // sum = sum / BASE;\n      }\n      prod.n_value[pvptr] = sum //* pvptr = sum;\n      return prod\n    },\n\n    /* A special adder/subtractor for the recursive divide and conquer\n       multiply algorithm.  Note: if sub is called, accum must\n       be larger that what is being subtracted.  Also, accum and val\n       must have n_scale = 0.  (e.g. they must look like integers. *) */\n    _bc_shift_addsub: function (accum, val, shift, sub) {\n      var accp, valp // signed char *accp, *valp;\n      var count, carry // int  count, carry;\n      count = val.n_len\n      if (val.n_value[0] === 0) {\n        count--\n      }\n\n      // assert (accum->n_len+accum->n_scale >= shift+count);\n      if (accum.n_len + accum.n_scale < shift + count) {\n        throw new Error('len + scale < shift + count') // ?? I think that's what assert does :)\n      }\n\n      // Set up pointers and others\n      // (signed char *)(accum->n_value + accum->n_len + accum->n_scale - shift - 1);\n      accp = accum.n_len + accum.n_scale - shift - 1\n      valp = val.n_len = 1 // (signed char *)(val->n_value + val->n_len - 1);\n      carry = 0\n      if (sub) {\n        // Subtraction, carry is really borrow.\n        while (count--) {\n          accum.n_value[accp] -= val.n_value[valp--] + carry //* accp -= *valp-- + carry;\n          if (accum.n_value[accp] < 0) { // if (*accp < 0)\n            carry = 1\n            accum.n_value[accp--] += Libbcmath.BASE //* accp-- += BASE;\n          } else {\n            carry = 0\n            accp--\n          }\n        }\n        while (carry) {\n          accum.n_value[accp] -= carry //* accp -= carry;\n          if (accum.n_value[accp] < 0) { // if (*accp < 0)\n            accum.n_value[accp--] += Libbcmath.BASE //    *accp-- += BASE;\n          } else {\n            carry = 0\n          }\n        }\n      } else {\n        // Addition\n        while (count--) {\n          accum.n_value[accp] += val.n_value[valp--] + carry //* accp += *valp-- + carry;\n          if (accum.n_value[accp] > (Libbcmath.BASE - 1)) { // if (*accp > (BASE-1))\n            carry = 1\n            accum.n_value[accp--] -= Libbcmath.BASE //* accp-- -= BASE;\n          } else {\n            carry = 0\n            accp--\n          }\n        }\n        while (carry) {\n          accum.n_value[accp] += carry //* accp += carry;\n          if (accum.n_value[accp] > (Libbcmath.BASE - 1)) { // if (*accp > (BASE-1))\n            accum.n_value[accp--] -= Libbcmath.BASE //* accp-- -= BASE;\n          } else {\n            carry = 0\n          }\n        }\n      }\n      return true // accum is the pass-by-reference return\n    },\n\n    /* Recursive divide and conquer multiply algorithm.\n       based on\n       Let u = u0 + u1*(b^n)\n       Let v = v0 + v1*(b^n)\n       Then uv = (B^2n+B^n)*u1*v1 + B^n*(u1-u0)*(v0-v1) + (B^n+1)*u0*v0\n\n       B is the base of storage, number of digits in u1,u0 close to equal.\n    */\n    _bc_rec_mul: function (u, ulen, v, vlen, fullScale) {\n      var prod // @return\n      var u0, u1, v0, v1 // bc_num\n      // var u0len,\n      // var v0len // int\n      var m1, m2, m3, d1, d2 // bc_num\n      var n, prodlen, m1zero // int\n      var d1len, d2len // int\n        // Base case?\n      if ((ulen + vlen) < Libbcmath.MUL_BASE_DIGITS ||\n        ulen < Libbcmath.MUL_SMALL_DIGITS ||\n        vlen < Libbcmath.MUL_SMALL_DIGITS) {\n        return Libbcmath._bc_simp_mul(u, ulen, v, vlen, fullScale)\n      }\n\n      // Calculate n -- the u and v split point in digits.\n      n = Math.floor((Libbcmath.MAX(ulen, vlen) + 1) / 2)\n\n      // Split u and v.\n      if (ulen < n) {\n        u1 = Libbcmath.bc_init_num() // u1 = bc_copy_num (BCG(_zero_));\n        u0 = Libbcmath.new_sub_num(ulen, 0, u.n_value)\n      } else {\n        u1 = Libbcmath.new_sub_num(ulen - n, 0, u.n_value)\n        u0 = Libbcmath.new_sub_num(n, 0, u.n_value + ulen - n)\n      }\n      if (vlen < n) {\n        v1 = Libbcmath.bc_init_num() // bc_copy_num (BCG(_zero_));\n        v0 = Libbcmath.new_sub_num(vlen, 0, v.n_value)\n      } else {\n        v1 = Libbcmath.new_sub_num(vlen - n, 0, v.n_value)\n        v0 = Libbcmath.new_sub_num(n, 0, v.n_value + vlen - n)\n      }\n      Libbcmath._bc_rm_leading_zeros(u1)\n      Libbcmath._bc_rm_leading_zeros(u0)\n      // var u0len = u0.n_len\n      Libbcmath._bc_rm_leading_zeros(v1)\n      Libbcmath._bc_rm_leading_zeros(v0)\n      // var v0len = v0.n_len\n\n      m1zero = Libbcmath.bc_is_zero(u1) || Libbcmath.bc_is_zero(v1)\n\n      // Calculate sub results ...\n      d1 = Libbcmath.bc_init_num() // needed?\n      d2 = Libbcmath.bc_init_num() // needed?\n      d1 = Libbcmath.bc_sub(u1, u0, 0)\n      d1len = d1.n_len\n\n      d2 = Libbcmath.bc_sub(v0, v1, 0)\n      d2len = d2.n_len\n\n      // Do recursive multiplies and shifted adds.\n      if (m1zero) {\n        m1 = Libbcmath.bc_init_num() // bc_copy_num (BCG(_zero_));\n      } else {\n        // m1 = Libbcmath.bc_init_num(); //allow pass-by-ref\n        m1 = Libbcmath._bc_rec_mul(u1, u1.n_len, v1, v1.n_len, 0)\n      }\n      if (Libbcmath.bc_is_zero(d1) || Libbcmath.bc_is_zero(d2)) {\n        m2 = Libbcmath.bc_init_num() // bc_copy_num (BCG(_zero_));\n      } else {\n        // m2 = Libbcmath.bc_init_num(); //allow pass-by-ref\n        m2 = Libbcmath._bc_rec_mul(d1, d1len, d2, d2len, 0)\n      }\n\n      if (Libbcmath.bc_is_zero(u0) || Libbcmath.bc_is_zero(v0)) {\n        m3 = Libbcmath.bc_init_num() // bc_copy_num (BCG(_zero_));\n      } else {\n        // m3 = Libbcmath.bc_init_num(); //allow pass-by-ref\n        m3 = Libbcmath._bc_rec_mul(u0, u0.n_len, v0, v0.n_len, 0)\n      }\n\n      // Initialize product\n      prodlen = ulen + vlen + 1\n      prod = Libbcmath.bc_new_num(prodlen, 0)\n\n      if (!m1zero) {\n        Libbcmath._bc_shift_addsub(prod, m1, 2 * n, 0)\n        Libbcmath._bc_shift_addsub(prod, m1, n, 0)\n      }\n      Libbcmath._bc_shift_addsub(prod, m3, n, 0)\n      Libbcmath._bc_shift_addsub(prod, m3, 0, 0)\n      Libbcmath._bc_shift_addsub(prod, m2, n, d1.n_sign !== d2.n_sign)\n\n      return prod\n        // Now clean up!\n        // bc_free_num (&u1);\n        // bc_free_num (&u0);\n        // bc_free_num (&v1);\n        // bc_free_num (&m1);\n        // bc_free_num (&v0);\n        // bc_free_num (&m2);\n        // bc_free_num (&m3);\n        // bc_free_num (&d1);\n        // bc_free_num (&d2);\n    },\n\n    /**\n     *\n     * @param {bc_num} n1\n     * @param {bc_num} n2\n     * @param {boolean} useSign\n     * @param {boolean} ignoreLast\n     * @return -1, 0, 1 (see bc_compare)\n     */\n    _bc_do_compare: function (n1, n2, useSign, ignoreLast) {\n      var n1ptr, n2ptr // int\n      var count // int\n        // First, compare signs.\n      if (useSign && (n1.n_sign !== n2.n_sign)) {\n        if (n1.n_sign === Libbcmath.PLUS) {\n          return (1) // Positive N1 > Negative N2\n        } else {\n          return (-1) // Negative N1 < Positive N1\n        }\n      }\n\n      // Now compare the magnitude.\n      if (n1.n_len !== n2.n_len) {\n        if (n1.n_len > n2.n_len) { // Magnitude of n1 > n2.\n          if (!useSign || (n1.n_sign === Libbcmath.PLUS)) {\n            return (1)\n          } else {\n            return (-1)\n          }\n        } else { // Magnitude of n1 < n2.\n          if (!useSign || (n1.n_sign === Libbcmath.PLUS)) {\n            return (-1)\n          } else {\n            return (1)\n          }\n        }\n      }\n\n      /* If we get here, they have the same number of integer digits.\n     check the integer part and the equal length part of the fraction. */\n      count = n1.n_len + Math.min(n1.n_scale, n2.n_scale)\n      n1ptr = 0\n      n2ptr = 0\n\n      while ((count > 0) && (n1.n_value[n1ptr] === n2.n_value[n2ptr])) {\n        n1ptr++\n        n2ptr++\n        count--\n      }\n\n      if (ignoreLast && (count === 1) && (n1.n_scale === n2.n_scale)) {\n        return (0)\n      }\n\n      if (count !== 0) {\n        if (n1.n_value[n1ptr] > n2.n_value[n2ptr]) { // Magnitude of n1 > n2.\n          if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n            return (1)\n          } else {\n            return (-1)\n          }\n        } else { // Magnitude of n1 < n2.\n          if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n            return (-1)\n          } else {\n            return (1)\n          }\n        }\n      }\n\n      // They are equal up to the last part of the equal part of the fraction.\n      if (n1.n_scale !== n2.n_scale) {\n        if (n1.n_scale > n2.n_scale) {\n          for (count = (n1.n_scale - n2.n_scale); count > 0; count--) {\n            if (n1.n_value[n1ptr++] !== 0) { // Magnitude of n1 > n2.\n              if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n                return (1)\n              } else {\n                return (-1)\n              }\n            }\n          }\n        } else {\n          for (count = (n2.n_scale - n1.n_scale); count > 0; count--) {\n            if (n2.n_value[n2ptr++] !== 0) { // Magnitude of n1 < n2.\n              if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n                return (-1)\n              } else {\n                return (1)\n              }\n            }\n          }\n        }\n      }\n\n      // They must be equal!\n      return (0)\n    },\n\n    /* Here is the full subtract routine that takes care of negative numbers.\n   N2 is subtracted from N1 and the result placed in RESULT.  SCALE_MIN\n   is the minimum scale for the result. */\n    bc_sub: function (n1, n2, scaleMin) {\n      var diff // bc_num\n      var cmpRes, resScale // int\n      if (n1.n_sign !== n2.n_sign) {\n        diff = Libbcmath._bc_do_add(n1, n2, scaleMin)\n        diff.n_sign = n1.n_sign\n      } else { // subtraction must be done.\n        // Compare magnitudes.\n        cmpRes = Libbcmath._bc_do_compare(n1, n2, false, false)\n        switch (cmpRes) {\n          case -1:\n            // n1 is less than n2, subtract n1 from n2.\n            diff = Libbcmath._bc_do_sub(n2, n1, scaleMin)\n            diff.n_sign = (n2.n_sign === Libbcmath.PLUS ? Libbcmath.MINUS : Libbcmath.PLUS)\n            break\n          case 0:\n            // They are equal! return zero!\n            resScale = Libbcmath.MAX(scaleMin, Libbcmath.MAX(n1.n_scale, n2.n_scale))\n            diff = Libbcmath.bc_new_num(1, resScale)\n            Libbcmath.memset(diff.n_value, 0, 0, resScale + 1)\n            break\n          case 1:\n            // n2 is less than n1, subtract n2 from n1.\n            diff = Libbcmath._bc_do_sub(n1, n2, scaleMin)\n            diff.n_sign = n1.n_sign\n            break\n        }\n      }\n\n      // Clean up and return.\n      // bc_free_num (result);\n      //* result = diff;\n      return diff\n    },\n\n    _bc_do_add: function (n1, n2, scaleMin) {\n      var sum // bc_num\n      var sumScale, sumDigits // int\n      var n1ptr, n2ptr, sumptr // int\n      var carry, n1bytes, n2bytes // int\n      var tmp // int\n\n      // Prepare sum.\n      sumScale = Libbcmath.MAX(n1.n_scale, n2.n_scale)\n      sumDigits = Libbcmath.MAX(n1.n_len, n2.n_len) + 1\n      sum = Libbcmath.bc_new_num(sumDigits, Libbcmath.MAX(sumScale, scaleMin))\n\n      // Start with the fraction part.  Initialize the pointers.\n      n1bytes = n1.n_scale\n      n2bytes = n2.n_scale\n      n1ptr = (n1.n_len + n1bytes - 1)\n      n2ptr = (n2.n_len + n2bytes - 1)\n      sumptr = (sumScale + sumDigits - 1)\n\n      // Add the fraction part.  First copy the longer fraction\n      // (ie when adding 1.2345 to 1 we know .2345 is correct already) .\n      if (n1bytes !== n2bytes) {\n        if (n1bytes > n2bytes) {\n          // n1 has more dp then n2\n          while (n1bytes > n2bytes) {\n            sum.n_value[sumptr--] = n1.n_value[n1ptr--]\n              // *sumptr-- = *n1ptr--;\n            n1bytes--\n          }\n        } else {\n          // n2 has more dp then n1\n          while (n2bytes > n1bytes) {\n            sum.n_value[sumptr--] = n2.n_value[n2ptr--]\n              // *sumptr-- = *n2ptr--;\n            n2bytes--\n          }\n        }\n      }\n\n      // Now add the remaining fraction part and equal size integer parts.\n      n1bytes += n1.n_len\n      n2bytes += n2.n_len\n      carry = 0\n      while ((n1bytes > 0) && (n2bytes > 0)) {\n        // add the two numbers together\n        tmp = n1.n_value[n1ptr--] + n2.n_value[n2ptr--] + carry\n          // *sumptr = *n1ptr-- + *n2ptr-- + carry;\n          // check if they are >= 10 (impossible to be more then 18)\n        if (tmp >= Libbcmath.BASE) {\n          carry = 1\n          tmp -= Libbcmath.BASE // yep, subtract 10, add a carry\n        } else {\n          carry = 0\n        }\n        sum.n_value[sumptr] = tmp\n        sumptr--\n        n1bytes--\n        n2bytes--\n      }\n\n      // Now add carry the [rest of the] longer integer part.\n      if (n1bytes === 0) {\n        // n2 is a bigger number then n1\n        while (n2bytes-- > 0) {\n          tmp = n2.n_value[n2ptr--] + carry\n            // *sumptr = *n2ptr-- + carry;\n          if (tmp >= Libbcmath.BASE) {\n            carry = 1\n            tmp -= Libbcmath.BASE\n          } else {\n            carry = 0\n          }\n          sum.n_value[sumptr--] = tmp\n        }\n      } else {\n        // n1 is bigger then n2..\n        while (n1bytes-- > 0) {\n          tmp = n1.n_value[n1ptr--] + carry\n            // *sumptr = *n1ptr-- + carry;\n          if (tmp >= Libbcmath.BASE) {\n            carry = 1\n            tmp -= Libbcmath.BASE\n          } else {\n            carry = 0\n          }\n          sum.n_value[sumptr--] = tmp\n        }\n      }\n\n      // Set final carry.\n      if (carry === 1) {\n        sum.n_value[sumptr] += 1\n          // *sumptr += 1;\n      }\n\n      // Adjust sum and return.\n      Libbcmath._bc_rm_leading_zeros(sum)\n      return sum\n    },\n\n    /**\n     * Perform a subtraction\n     *\n     * Perform subtraction: N2 is subtracted from N1 and the value is\n     *  returned.  The signs of N1 and N2 are ignored.  Also, N1 is\n     *  assumed to be larger than N2.  SCALE_MIN is the minimum scale\n     *  of the result.\n     *\n     * Basic school maths says to subtract 2 numbers..\n     * 1. make them the same length, the decimal places, and the integer part\n     * 2. start from the right and subtract the two numbers from each other\n     * 3. if the sum of the 2 numbers < 0, carry -1 to the next set and add 10\n     * (ie 18 > carry 1 becomes 8). thus 0.9 + 0.9 = 1.8\n     *\n     * @param {bc_num} n1\n     * @param {bc_num} n2\n     * @param {int} scaleMin\n     * @return bc_num\n     */\n    _bc_do_sub: function (n1, n2, scaleMin) {\n      var diff // bc_num\n      var diffScale, diffLen // int\n      var minScale, minLen // int\n      var n1ptr, n2ptr, diffptr // int\n      var borrow, count, val // int\n        // Allocate temporary storage.\n      diffLen = Libbcmath.MAX(n1.n_len, n2.n_len)\n      diffScale = Libbcmath.MAX(n1.n_scale, n2.n_scale)\n      minLen = Libbcmath.MIN(n1.n_len, n2.n_len)\n      minScale = Libbcmath.MIN(n1.n_scale, n2.n_scale)\n      diff = Libbcmath.bc_new_num(diffLen, Libbcmath.MAX(diffScale, scaleMin))\n\n      /* Not needed?\n      // Zero extra digits made by scaleMin.\n      if (scaleMin > diffScale) {\n        diffptr = (char *) (diff->n_value + diffLen + diffScale);\n        for (count = scaleMin - diffScale; count > 0; count--) {\n          *diffptr++ = 0;\n        }\n      }\n      */\n\n      // Initialize the subtract.\n      n1ptr = (n1.n_len + n1.n_scale - 1)\n      n2ptr = (n2.n_len + n2.n_scale - 1)\n      diffptr = (diffLen + diffScale - 1)\n\n      // Subtract the numbers.\n      borrow = 0\n\n      // Take care of the longer scaled number.\n      if (n1.n_scale !== minScale) {\n        // n1 has the longer scale\n        for (count = n1.n_scale - minScale; count > 0; count--) {\n          diff.n_value[diffptr--] = n1.n_value[n1ptr--]\n            // *diffptr-- = *n1ptr--;\n        }\n      } else {\n        // n2 has the longer scale\n        for (count = n2.n_scale - minScale; count > 0; count--) {\n          val = 0 - n2.n_value[n2ptr--] - borrow\n            // val = - *n2ptr-- - borrow;\n          if (val < 0) {\n            val += Libbcmath.BASE\n            borrow = 1\n          } else {\n            borrow = 0\n          }\n          diff.n_value[diffptr--] = val\n            //* diffptr-- = val;\n        }\n      }\n\n      // Now do the equal length scale and integer parts.\n      for (count = 0; count < minLen + minScale; count++) {\n        val = n1.n_value[n1ptr--] - n2.n_value[n2ptr--] - borrow\n          // val = *n1ptr-- - *n2ptr-- - borrow;\n        if (val < 0) {\n          val += Libbcmath.BASE\n          borrow = 1\n        } else {\n          borrow = 0\n        }\n        diff.n_value[diffptr--] = val\n          //* diffptr-- = val;\n      }\n\n      // If n1 has more digits then n2, we now do that subtract.\n      if (diffLen !== minLen) {\n        for (count = diffLen - minLen; count > 0; count--) {\n          val = n1.n_value[n1ptr--] - borrow\n            // val = *n1ptr-- - borrow;\n          if (val < 0) {\n            val += Libbcmath.BASE\n            borrow = 1\n          } else {\n            borrow = 0\n          }\n          diff.n_value[diffptr--] = val\n        }\n      }\n\n      // Clean up and return.\n      Libbcmath._bc_rm_leading_zeros(diff)\n      return diff\n    },\n\n    /**\n     *\n     * @param {int} length\n     * @param {int} scale\n     * @return bc_num\n     */\n    bc_new_num: function (length, scale) {\n      var temp // bc_num\n      temp = new Libbcmath.bc_num() // eslint-disable-line new-cap\n      temp.n_sign = Libbcmath.PLUS\n      temp.n_len = length\n      temp.n_scale = scale\n      temp.n_value = Libbcmath.safe_emalloc(1, length + scale, 0)\n      Libbcmath.memset(temp.n_value, 0, 0, length + scale)\n      return temp\n    },\n\n    safe_emalloc: function (size, len, extra) {\n      return Array((size * len) + extra)\n    },\n\n    /**\n     * Create a new number\n     */\n    bc_init_num: function () {\n      return new Libbcmath.bc_new_num(1, 0) // eslint-disable-line new-cap\n    },\n\n    _bc_rm_leading_zeros: function (num) {\n      // We can move n_value to point to the first non zero digit!\n      while ((num.n_value[0] === 0) && (num.n_len > 1)) {\n        num.n_value.shift()\n        num.n_len--\n      }\n    },\n\n    /**\n     * Convert to bc_num detecting scale\n     */\n    php_str2num: function (str) {\n      var p\n      p = str.indexOf('.')\n      if (p === -1) {\n        return Libbcmath.bc_str2num(str, 0)\n      } else {\n        return Libbcmath.bc_str2num(str, (str.length - p))\n      }\n    },\n\n    CH_VAL: function (c) {\n      return c - '0' // ??\n    },\n\n    BCD_CHAR: function (d) {\n      return d + '0' // ??\n    },\n\n    isdigit: function (c) {\n      return isNaN(parseInt(c, 10))\n    },\n\n    bc_str2num: function (strIn, scale) {\n      var str, num, ptr, digits, strscale, zeroInt, nptr\n        // remove any non-expected characters\n        // Check for valid number and count digits.\n\n      str = strIn.split('') // convert to array\n      ptr = 0 // str\n      digits = 0\n      strscale = 0\n      zeroInt = false\n      if ((str[ptr] === '+') || (str[ptr] === '-')) {\n        ptr++ // Sign\n      }\n      while (str[ptr] === '0') {\n        ptr++ // Skip leading zeros.\n      }\n      // while (Libbcmath.isdigit(str[ptr])) {\n      while ((str[ptr]) % 1 === 0) { // Libbcmath.isdigit(str[ptr])) {\n        ptr++\n        digits++ // digits\n      }\n\n      if (str[ptr] === '.') {\n        ptr++ // decimal point\n      }\n      // while (Libbcmath.isdigit(str[ptr])) {\n      while ((str[ptr]) % 1 === 0) { // Libbcmath.isdigit(str[ptr])) {\n        ptr++\n        strscale++ // digits\n      }\n\n      if ((str[ptr]) || (digits + strscale === 0)) {\n        // invalid number, return 0\n        return Libbcmath.bc_init_num()\n          //* num = bc_copy_num (BCG(_zero_));\n      }\n\n      // Adjust numbers and allocate storage and initialize fields.\n      strscale = Libbcmath.MIN(strscale, scale)\n      if (digits === 0) {\n        zeroInt = true\n        digits = 1\n      }\n\n      num = Libbcmath.bc_new_num(digits, strscale)\n\n      // Build the whole number.\n      ptr = 0 // str\n      if (str[ptr] === '-') {\n        num.n_sign = Libbcmath.MINUS\n          // (*num)->n_sign = MINUS;\n        ptr++\n      } else {\n        num.n_sign = Libbcmath.PLUS\n          // (*num)->n_sign = PLUS;\n        if (str[ptr] === '+') {\n          ptr++\n        }\n      }\n      while (str[ptr] === '0') {\n        ptr++ // Skip leading zeros.\n      }\n\n      nptr = 0 // (*num)->n_value;\n      if (zeroInt) {\n        num.n_value[nptr++] = 0\n        digits = 0\n      }\n      for (; digits > 0; digits--) {\n        num.n_value[nptr++] = Libbcmath.CH_VAL(str[ptr++])\n          //* nptr++ = CH_VAL(*ptr++);\n      }\n\n      // Build the fractional part.\n      if (strscale > 0) {\n        ptr++ // skip the decimal point!\n        for (; strscale > 0; strscale--) {\n          num.n_value[nptr++] = Libbcmath.CH_VAL(str[ptr++])\n        }\n      }\n\n      return num\n    },\n\n    cint: function (v) {\n      if (typeof v === 'undefined') {\n        v = 0\n      }\n      var x = parseInt(v, 10)\n      if (isNaN(x)) {\n        x = 0\n      }\n      return x\n    },\n\n    /**\n     * Basic min function\n     * @param {int} a\n     * @param {int} b\n     */\n    MIN: function (a, b) {\n      return ((a > b) ? b : a)\n    },\n\n    /**\n     * Basic max function\n     * @param {int} a\n     * @param {int} b\n     */\n    MAX: function (a, b) {\n      return ((a > b) ? a : b)\n    },\n\n    /**\n     * Basic odd function\n     * @param {int} a\n     */\n    ODD: function (a) {\n      return (a & 1)\n    },\n\n    /**\n     * replicate c function\n     * @param {array} r     return (by reference)\n     * @param {int} ptr\n     * @param {string} chr    char to fill\n     * @param {int} len       length to fill\n     */\n    memset: function (r, ptr, chr, len) {\n      var i\n      for (i = 0; i < len; i++) {\n        r[ptr + i] = chr\n      }\n    },\n\n    /**\n     * Replacement c function\n     * Obviously can't work like c does, so we've added an \"offset\"\n     * param so you could do memcpy(dest+1, src, len) as memcpy(dest, 1, src, len)\n     * Also only works on arrays\n     */\n    memcpy: function (dest, ptr, src, srcptr, len) {\n      var i\n      for (i = 0; i < len; i++) {\n        dest[ptr + i] = src[srcptr + i]\n      }\n      return true\n    },\n\n    /**\n     * Determine if the number specified is zero or not\n     * @param {bc_num} num    number to check\n     * @return boolean      true when zero, false when not zero.\n     */\n    bc_is_zero: function (num) {\n      var count // int\n      var nptr // int\n      // Quick check.\n      // if (num === BCG(_zero_)) return TRUE;\n      // Initialize\n      count = num.n_len + num.n_scale\n      nptr = 0 // num->n_value;\n      // The check\n      while ((count > 0) && (num.n_value[nptr++] === 0)) {\n        count--\n      }\n\n      if (count !== 0) {\n        return false\n      } else {\n        return true\n      }\n    },\n\n    bc_out_of_memory: function () {\n      throw new Error('(BC) Out of memory')\n    }\n  }\n  return Libbcmath\n}\n"]}