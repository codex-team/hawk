{"version":3,"sources":["../../../src/php/strings/substr.js"],"names":["module","exports","substr","str","start","len","end","length","iniVal","require","undefined","slice","i","allBMP","es","el","se","ret","test","charAt","surrogatePairs","exec","li","lastIndex"],"mappings":"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","file":"substr.js","sourcesContent":["module.exports = function substr (str, start, len) {\n  //  discuss at: http://locutus.io/php/substr/\n  // original by: Martijn Wieringa\n  // bugfixed by: T.Wild\n  // improved by: Onno Marsman (https://twitter.com/onnomarsman)\n  // improved by: Brett Zamir (http://brett-zamir.me)\n  //  revised by: Theriault (https://github.com/Theriault)\n  //      note 1: Handles rare Unicode characters if 'unicode.semantics' ini (PHP6) is set to 'on'\n  //   example 1: substr('abcdef', 0, -1)\n  //   returns 1: 'abcde'\n  //   example 2: substr(2, 0, -6)\n  //   returns 2: false\n  //   example 3: ini_set('unicode.semantics', 'on')\n  //   example 3: substr('a\\uD801\\uDC00', 0, -1)\n  //   returns 3: 'a'\n  //   example 4: ini_set('unicode.semantics', 'on')\n  //   example 4: substr('a\\uD801\\uDC00', 0, 2)\n  //   returns 4: 'a\\uD801\\uDC00'\n  //   example 5: ini_set('unicode.semantics', 'on')\n  //   example 5: substr('a\\uD801\\uDC00', -1, 1)\n  //   returns 5: '\\uD801\\uDC00'\n  //   example 6: ini_set('unicode.semantics', 'on')\n  //   example 6: substr('a\\uD801\\uDC00z\\uD801\\uDC00', -3, 2)\n  //   returns 6: '\\uD801\\uDC00z'\n  //   example 7: ini_set('unicode.semantics', 'on')\n  //   example 7: substr('a\\uD801\\uDC00z\\uD801\\uDC00', -3, -1)\n  //   returns 7: '\\uD801\\uDC00z'\n  //        test: skip-3 skip-4 skip-5 skip-6 skip-7\n\n  str += ''\n  var end = str.length\n\n  var iniVal = (typeof require !== 'undefined' ? require('../info/ini_get')('unicode.emantics') : undefined) || 'off'\n\n  if (iniVal === 'off') {\n    // assumes there are no non-BMP characters;\n    // if there may be such characters, then it is best to turn it on (critical in true XHTML/XML)\n    if (start < 0) {\n      start += end\n    }\n    if (typeof len !== 'undefined') {\n      if (len < 0) {\n        end = len + end\n      } else {\n        end = len + start\n      }\n    }\n\n    // PHP returns false if start does not fall within the string.\n    // PHP returns false if the calculated end comes before the calculated start.\n    // PHP returns an empty string if start and end are the same.\n    // Otherwise, PHP returns the portion of the string from start to end.\n    if (start >= str.length || start < 0 || start > end) {\n      return false\n    }\n\n    return str.slice(start, end)\n  }\n\n  // Full-blown Unicode including non-Basic-Multilingual-Plane characters\n  var i = 0\n  var allBMP = true\n  var es = 0\n  var el = 0\n  var se = 0\n  var ret = ''\n\n  for (i = 0; i < str.length; i++) {\n    if (/[\\uD800-\\uDBFF]/.test(str.charAt(i)) && /[\\uDC00-\\uDFFF]/.test(str.charAt(i + 1))) {\n      allBMP = false\n      break\n    }\n  }\n\n  if (!allBMP) {\n    if (start < 0) {\n      for (i = end - 1, es = (start += end); i >= es; i--) {\n        if (/[\\uDC00-\\uDFFF]/.test(str.charAt(i)) && /[\\uD800-\\uDBFF]/.test(str.charAt(i - 1))) {\n          start--\n          es--\n        }\n      }\n    } else {\n      var surrogatePairs = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g\n      while ((surrogatePairs.exec(str)) !== null) {\n        var li = surrogatePairs.lastIndex\n        if (li - 2 < start) {\n          start++\n        } else {\n          break\n        }\n      }\n    }\n\n    if (start >= end || start < 0) {\n      return false\n    }\n    if (len < 0) {\n      for (i = end - 1, el = (end += len); i >= el; i--) {\n        if (/[\\uDC00-\\uDFFF]/.test(str.charAt(i)) && /[\\uD800-\\uDBFF]/.test(str.charAt(i - 1))) {\n          end--\n          el--\n        }\n      }\n      if (start > end) {\n        return false\n      }\n      return str.slice(start, end)\n    } else {\n      se = start + len\n      for (i = start; i < se; i++) {\n        ret += str.charAt(i)\n        if (/[\\uD800-\\uDBFF]/.test(str.charAt(i)) && /[\\uDC00-\\uDFFF]/.test(str.charAt(i + 1))) {\n          // Go one further, since one of the \"characters\" is part of a surrogate pair\n          se++\n        }\n      }\n      return ret\n    }\n  }\n}\n"]}