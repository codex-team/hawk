{"version":3,"sources":["../../../src/php/strings/sscanf.js"],"names":["module","exports","sscanf","str","format","retArr","_NWS","args","arguments","digit","_setExtraConversionSpecs","offset","matches","slice","match","lgth","length","push","_finish","i","value","_addNext","j","regex","cb","assign","remaining","check","width","substr","exec","key","undefined","testNull","apply","Error","charAt","prePattern","RegExp","preConvs","tmpDigit","msg","parseInt","sizeCode","lastIndex","pattern","num","sign","hex","oct","dec","decInt","parseFloat","e","test"],"mappings":"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","file":"sscanf.js","sourcesContent":["module.exports = function sscanf (str, format) {\n  //  discuss at: http://locutus.io/php/sscanf/\n  // original by: Brett Zamir (http://brett-zamir.me)\n  //   example 1: sscanf('SN/2350001', 'SN/%d')\n  //   returns 1: [2350001]\n  //   example 2: var myVar = {}\n  //   example 2: sscanf('SN/2350001', 'SN/%d', myVar)\n  //   example 2: var $result = myVar.value\n  //   returns 2: 2350001\n  //   example 3: sscanf(\"10--20\", \"%2$d--%1$d\") // Must escape '$' in PHP, but not JS\n  //   returns 3: [20, 10]\n\n  var retArr = []\n  var _NWS = /\\S/\n  var args = arguments\n  var digit\n\n  var _setExtraConversionSpecs = function (offset) {\n    // Since a mismatched character sets us off track from future\n    // legitimate finds, we just scan\n    // to the end for any other conversion specifications (besides a percent literal),\n    // setting them to null\n    // sscanf seems to disallow all conversion specification components (of sprintf)\n    // except for type specifiers\n    // Do not allow % in last char. class\n    // var matches = format.match(/%[+-]?([ 0]|'.)?-?\\d*(\\.\\d+)?[bcdeufFosxX]/g);\n    // Do not allow % in last char. class:\n    var matches = format.slice(offset).match(/%[cdeEufgosxX]/g)\n    // b, F,G give errors in PHP, but 'g', though also disallowed, doesn't\n    if (matches) {\n      var lgth = matches.length\n      while (lgth--) {\n        retArr.push(null)\n      }\n    }\n    return _finish()\n  }\n\n  var _finish = function () {\n    if (args.length === 2) {\n      return retArr\n    }\n    for (var i = 0; i < retArr.length; ++i) {\n      args[i + 2].value = retArr[i]\n    }\n    return i\n  }\n\n  var _addNext = function (j, regex, cb) {\n    if (assign) {\n      var remaining = str.slice(j)\n      var check = width ? remaining.substr(0, width) : remaining\n      var match = regex.exec(check)\n      // @todo: Make this more readable\n      var key = digit !== undefined\n        ? digit\n        : retArr.length\n      var testNull = retArr[key] = match\n          ? (cb\n            ? cb.apply(null, match)\n            : match[0])\n          : null\n      if (testNull === null) {\n        throw new Error('No match in string')\n      }\n      return j + match[0].length\n    }\n    return j\n  }\n\n  if (arguments.length < 2) {\n    throw new Error('Not enough arguments passed to sscanf')\n  }\n\n  // PROCESS\n  for (var i = 0, j = 0; i < format.length; i++) {\n    var width = 0\n    var assign = true\n\n    if (format.charAt(i) === '%') {\n      if (format.charAt(i + 1) === '%') {\n        if (str.charAt(j) === '%') {\n          // a matched percent literal\n          // skip beyond duplicated percent\n          ++i\n          ++j\n          continue\n        }\n        // Format indicated a percent literal, but not actually present\n        return _setExtraConversionSpecs(i + 2)\n      }\n\n      // CHARACTER FOLLOWING PERCENT IS NOT A PERCENT\n\n      // We need 'g' set to get lastIndex\n      var prePattern = new RegExp('^(?:(\\\\d+)\\\\$)?(\\\\*)?(\\\\d*)([hlL]?)', 'g')\n\n      var preConvs = prePattern.exec(format.slice(i + 1))\n\n      var tmpDigit = digit\n      if (tmpDigit && preConvs[1] === undefined) {\n        var msg = 'All groups in sscanf() must be expressed as numeric if '\n        msg += 'any have already been used'\n        throw new Error(msg)\n      }\n      digit = preConvs[1] ? parseInt(preConvs[1], 10) - 1 : undefined\n\n      assign = !preConvs[2]\n      width = parseInt(preConvs[3], 10)\n      var sizeCode = preConvs[4]\n      i += prePattern.lastIndex\n\n      // @todo: Does PHP do anything with these? Seems not to matter\n      if (sizeCode) {\n        // This would need to be processed later\n        switch (sizeCode) {\n          case 'h':\n          case 'l':\n          case 'L':\n            // Treats subsequent as short int (for d,i,n) or unsigned short int (for o,u,x)\n            // Treats subsequent as long int (for d,i,n), or unsigned long int (for o,u,x);\n            //    or as double (for e,f,g) instead of float or wchar_t instead of char\n            // Treats subsequent as long double (for e,f,g)\n            break\n          default:\n            throw new Error('Unexpected size specifier in sscanf()!')\n        }\n      }\n      // PROCESS CHARACTER\n      try {\n        // For detailed explanations, see http://web.archive.org/web/20031128125047/http://www.uwm.edu/cgi-bin/IMT/wwwman?topic=scanf%283%29&msection=\n        // Also http://www.mathworks.com/access/helpdesk/help/techdoc/ref/sscanf.html\n        // p, S, C arguments in C function not available\n        // DOCUMENTED UNDER SSCANF\n        switch (format.charAt(i + 1)) {\n          case 'F':\n            // Not supported in PHP sscanf; the argument is treated as a float, and\n            //  presented as a floating-point number (non-locale aware)\n            // sscanf doesn't support locales, so no need for two (see %f)\n            break\n          case 'g':\n            // Not supported in PHP sscanf; shorter of %e and %f\n            // Irrelevant to input conversion\n            break\n          case 'G':\n            // Not supported in PHP sscanf; shorter of %E and %f\n            // Irrelevant to input conversion\n            break\n          case 'b':\n            // Not supported in PHP sscanf; the argument is treated as an integer,\n            // and presented as a binary number\n            // Not supported - couldn't distinguish from other integers\n            break\n          case 'i':\n            // Integer with base detection (Equivalent of 'd', but base 0 instead of 10)\n            var pattern = /([+-])?(?:(?:0x([\\da-fA-F]+))|(?:0([0-7]+))|(\\d+))/\n            j = _addNext(j, pattern, function (num, sign, hex,\n            oct, dec) {\n              return hex ? parseInt(num, 16) : oct ? parseInt(num, 8) : parseInt(num, 10)\n            })\n            break\n          case 'n':\n            // Number of characters processed so far\n            retArr[digit !== undefined ? digit : retArr.length - 1] = j\n            break\n            // DOCUMENTED UNDER SPRINTF\n          case 'c':\n            // Get character; suppresses skipping over whitespace!\n            // (but shouldn't be whitespace in format anyways, so no difference here)\n            // Non-greedy match\n            j = _addNext(j, new RegExp('.{1,' + (width || 1) + '}'))\n            break\n          case 'D':\n          case 'd':\n            // sscanf documented decimal number; equivalent of 'd';\n            // Optionally signed decimal integer\n            j = _addNext(j, /([+-])?(?:0*)(\\d+)/, function (num, sign, dec) {\n              // Ignores initial zeroes, unlike %i and parseInt()\n              var decInt = parseInt((sign || '') + dec, 10)\n              if (decInt < 0) {\n                // PHP also won't allow less than -2147483648\n                // integer overflow with negative\n                return decInt < -2147483648 ? -2147483648 : decInt\n              } else {\n                // PHP also won't allow greater than -2147483647\n                return decInt < 2147483647 ? decInt : 2147483647\n              }\n            })\n            break\n          case 'f':\n          case 'E':\n          case 'e':\n            // Although sscanf doesn't support locales,\n            // this is used instead of '%F'; seems to be same as %e\n            // These don't discriminate here as both allow exponential float of either case\n            j = _addNext(j, /([+-])?(?:0*)(\\d*\\.?\\d*(?:[eE]?\\d+)?)/, function (num, sign, dec) {\n              if (dec === '.') {\n                return null\n              }\n              // Ignores initial zeroes, unlike %i and parseFloat()\n              return parseFloat((sign || '') + dec)\n            })\n            break\n          case 'u':\n            // unsigned decimal integer\n            // We won't deal with integer overflows due to signs\n            j = _addNext(j, /([+-])?(?:0*)(\\d+)/, function (num, sign, dec) {\n              // Ignores initial zeroes, unlike %i and parseInt()\n              var decInt = parseInt(dec, 10)\n              if (sign === '-') {\n                // PHP also won't allow greater than 4294967295\n                // integer overflow with negative\n                return 4294967296 - decInt\n              } else {\n                return decInt < 4294967295 ? decInt : 4294967295\n              }\n            })\n            break\n          case 'o':\n              // Octal integer // @todo: add overflows as above?\n            j = _addNext(j, /([+-])?(?:0([0-7]+))/, function (num, sign, oct) {\n              return parseInt(num, 8)\n            })\n            break\n          case 's':\n            // Greedy match\n            j = _addNext(j, /\\S+/)\n            break\n          case 'X':\n          case 'x':\n          // Same as 'x'?\n            // @todo: add overflows as above?\n            // Initial 0x not necessary here\n            j = _addNext(j, /([+-])?(?:(?:0x)?([\\da-fA-F]+))/, function (num, sign, hex) {\n              return parseInt(num, 16)\n            })\n            break\n          case '':\n            // If no character left in expression\n            throw new Error('Missing character after percent mark in sscanf() format argument')\n          default:\n            throw new Error('Unrecognized character after percent mark in sscanf() format argument')\n        }\n      } catch (e) {\n        if (e === 'No match in string') {\n          // Allow us to exit\n          return _setExtraConversionSpecs(i + 2)\n        }\n        // Calculate skipping beyond initial percent too\n      }\n      ++i\n    } else if (format.charAt(i) !== str.charAt(j)) {\n        // @todo: Double-check i whitespace ignored in string and/or formats\n      _NWS.lastIndex = 0\n      if ((_NWS)\n        .test(str.charAt(j)) || str.charAt(j) === '') {\n        // Whitespace doesn't need to be an exact match)\n        return _setExtraConversionSpecs(i + 1)\n      } else {\n        // Adjust strings when encounter non-matching whitespace,\n        // so they align in future checks above\n        // Ok to replace with j++;?\n        str = str.slice(0, j) + str.slice(j + 1)\n        i--\n      }\n    } else {\n      j++\n    }\n  }\n\n  // POST-PROCESSING\n  return _finish()\n}\n"]}