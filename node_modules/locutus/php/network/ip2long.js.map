{"version":3,"sources":["../../../src/php/network/ip2long.js"],"names":["module","exports","ip2long","argIP","i","pattern","RegExp","join","match","length","parseInt","push","Math","pow"],"mappings":";;AAAAA,OAAOC,OAAP,GAAiB,SAASC,OAAT,CAAkBC,KAAlB,EAAyB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAIC,IAAI,CAAR;AACA;AACA;;AAEA,MAAMC,UAAU,IAAIC,MAAJ,CAAW,CACzB,kCADyB,EAEzB,yCAFyB,EAGzB,yCAHyB,EAIzB,0CAJyB,EAKzBC,IALyB,CAKpB,EALoB,CAAX,EAKJ,GALI,CAAhB;;AAOAJ,UAAQA,MAAMK,KAAN,CAAYH,OAAZ,CAAR,CAzBwC,CAyBX;AAC7B,MAAI,CAACF,KAAL,EAAY;AACV;AACA,WAAO,KAAP;AACD;AACD;AACAA,QAAM,CAAN,IAAW,CAAX;AACA,OAAKC,IAAI,CAAT,EAAYA,IAAI,CAAhB,EAAmBA,KAAK,CAAxB,EAA2B;AACzBD,UAAM,CAAN,KAAY,CAAC,CAAE,CAACA,MAAMC,CAAN,KAAY,EAAb,EAAiBK,MAAhC;AACAN,UAAMC,CAAN,IAAWM,SAASP,MAAMC,CAAN,CAAT,KAAsB,CAAjC;AACD;AACD;AACA;AACAD,QAAMQ,IAAN,CAAW,GAAX,EAAgB,GAAhB,EAAqB,GAArB,EAA0B,GAA1B;AACA;AACAR,QAAM,IAAIA,MAAM,CAAN,CAAV,KAAuBS,KAAKC,GAAL,CAAS,GAAT,EAAc,IAAIV,MAAM,CAAN,CAAlB,CAAvB;AACA,MAAIA,MAAM,CAAN,KAAYA,MAAM,CAAN,CAAZ,IACFA,MAAM,CAAN,KAAYA,MAAM,CAAN,CADV,IAEFA,MAAM,CAAN,KAAYA,MAAM,CAAN,CAFV,IAGFA,MAAM,CAAN,KAAYA,MAAM,CAAN,CAHd,EAGwB;AACtB,WAAO,KAAP;AACD;;AAED,SAAOA,MAAM,CAAN,KAAYA,MAAM,CAAN,MAAa,CAAb,IAAkB,QAA9B,IACLA,MAAM,CAAN,KAAYA,MAAM,CAAN,KAAY,CAAZ,IAAiB,KAA7B,CADK,GAELA,MAAM,CAAN,KAAYA,MAAM,CAAN,KAAY,CAAZ,IAAiB,GAA7B,CAFK,GAGLA,MAAM,CAAN,IAAW,CAHb;AAID,CApDD","file":"ip2long.js","sourcesContent":["module.exports = function ip2long (argIP) {\n  //  discuss at: http://locutus.io/php/ip2long/\n  // original by: Waldo Malqui Silva (http://waldo.malqui.info)\n  // improved by: Victor\n  //  revised by: fearphage (http://http/my.opera.com/fearphage/)\n  //  revised by: Theriault (https://github.com/Theriault)\n  //    estarget: es2015\n  //   example 1: ip2long('192.0.34.166')\n  //   returns 1: 3221234342\n  //   example 2: ip2long('0.0xABCDEF')\n  //   returns 2: 11259375\n  //   example 3: ip2long('255.255.255.256')\n  //   returns 3: false\n\n  let i = 0\n  // PHP allows decimal, octal, and hexadecimal IP components.\n  // PHP allows between 1 (e.g. 127) to 4 (e.g 127.0.0.1) components.\n\n  const pattern = new RegExp([\n    '^([1-9]\\\\d*|0[0-7]*|0x[\\\\da-f]+)',\n    '(?:\\\\.([1-9]\\\\d*|0[0-7]*|0x[\\\\da-f]+))?',\n    '(?:\\\\.([1-9]\\\\d*|0[0-7]*|0x[\\\\da-f]+))?',\n    '(?:\\\\.([1-9]\\\\d*|0[0-7]*|0x[\\\\da-f]+))?$'\n  ].join(''), 'i')\n\n  argIP = argIP.match(pattern) // Verify argIP format.\n  if (!argIP) {\n    // Invalid format.\n    return false\n  }\n  // Reuse argIP variable for component counter.\n  argIP[0] = 0\n  for (i = 1; i < 5; i += 1) {\n    argIP[0] += !!((argIP[i] || '').length)\n    argIP[i] = parseInt(argIP[i]) || 0\n  }\n  // Continue to use argIP for overflow values.\n  // PHP does not allow any component to overflow.\n  argIP.push(256, 256, 256, 256)\n  // Recalculate overflow of last component supplied to make up for missing components.\n  argIP[4 + argIP[0]] *= Math.pow(256, 4 - argIP[0])\n  if (argIP[1] >= argIP[5] ||\n    argIP[2] >= argIP[6] ||\n    argIP[3] >= argIP[7] ||\n    argIP[4] >= argIP[8]) {\n    return false\n  }\n\n  return argIP[1] * (argIP[0] === 1 || 16777216) +\n    argIP[2] * (argIP[0] <= 2 || 65536) +\n    argIP[3] * (argIP[0] <= 3 || 256) +\n    argIP[4] * 1\n}\n"]}