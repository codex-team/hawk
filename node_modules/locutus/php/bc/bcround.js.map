{"version":3,"sources":["../../../src/php/bc/bcround.js"],"names":["module","exports","bcround","val","precision","_bc","require","libbcmath","temp","result","digit","rightOperand","bc_init_num","php_str2num","toString","n_scale","n_value","n_len","bc_new_num","n_sign","MINUS","bc_add"],"mappings":";;AAAAA,OAAOC,OAAP,GAAiB,SAASC,OAAT,CAAkBC,GAAlB,EAAuBC,SAAvB,EAAkC;AACjD;AACA;AACA;AACA;;AAEA,MAAIC,MAAMC,QAAQ,iBAAR,CAAV;AACA,MAAIC,YAAYF,KAAhB;;AAEA,MAAIG,IAAJ,EAAUC,MAAV,EAAkBC,KAAlB;AACA,MAAIC,YAAJ;;AAEA;AACAH,SAAOD,UAAUK,WAAV,EAAP;AACAJ,SAAOD,UAAUM,WAAV,CAAsBV,IAAIW,QAAJ,EAAtB,CAAP;;AAEA;AACA,MAAIV,aAAaI,KAAKO,OAAtB,EAA+B;AAC7B;AACA,WAAOP,KAAKO,OAAL,GAAeX,SAAtB,EAAiC;AAC/BI,WAAKQ,OAAL,CAAaR,KAAKS,KAAL,GAAaT,KAAKO,OAA/B,IAA0C,CAA1C;AACAP,WAAKO,OAAL;AACD;AACD,WAAOP,KAAKM,QAAL,EAAP;AACD;;AAED;AACA;AACAJ,UAAQF,KAAKQ,OAAL,CAAaR,KAAKS,KAAL,GAAab,SAA1B,CAAR;;AAEAO,iBAAeJ,UAAUK,WAAV,EAAf;AACAD,iBAAeJ,UAAUW,UAAV,CAAqB,CAArB,EAAwBd,SAAxB,CAAf;;AAEA,MAAIM,SAAS,CAAb,EAAgB;AACd;AACA;AACAC,iBAAaK,OAAb,CAAqBL,aAAaM,KAAb,GAAqBN,aAAaI,OAAlC,GAA4C,CAAjE,IAAsE,CAAtE;AACA,QAAIP,KAAKW,MAAL,KAAgBZ,UAAUa,KAA9B,EAAqC;AACnC;AACAT,mBAAaQ,MAAb,GAAsBZ,UAAUa,KAAhC;AACD;AACDX,aAASF,UAAUc,MAAV,CAAiBb,IAAjB,EAAuBG,YAAvB,EAAqCP,SAArC,CAAT;AACD,GATD,MASO;AACL;AACAK,aAASD,IAAT;AACD;;AAED,MAAIC,OAAOM,OAAP,GAAiBX,SAArB,EAAgC;AAC9BK,WAAOM,OAAP,GAAiBX,SAAjB;AACD;;AAED,SAAOK,OAAOK,QAAP,EAAP;AACD,CApDD","file":"bcround.js","sourcesContent":["module.exports = function bcround (val, precision) {\n  //  discuss at: http://locutus.io/php/bcround/\n  // original by: lmeyrick (https://sourceforge.net/projects/bcmath-js/)\n  //   example 1: bcround(1, 2)\n  //   returns 1: '1.00'\n\n  var _bc = require('../_helpers/_bc')\n  var libbcmath = _bc()\n\n  var temp, result, digit\n  var rightOperand\n\n  // create number\n  temp = libbcmath.bc_init_num()\n  temp = libbcmath.php_str2num(val.toString())\n\n  // check if any rounding needs\n  if (precision >= temp.n_scale) {\n    // nothing to round, just add the zeros.\n    while (temp.n_scale < precision) {\n      temp.n_value[temp.n_len + temp.n_scale] = 0\n      temp.n_scale++\n    }\n    return temp.toString()\n  }\n\n  // get the digit we are checking (1 after the precision)\n  // loop through digits after the precision marker\n  digit = temp.n_value[temp.n_len + precision]\n\n  rightOperand = libbcmath.bc_init_num()\n  rightOperand = libbcmath.bc_new_num(1, precision)\n\n  if (digit >= 5) {\n    // round away from zero by adding 1 (or -1) at the \"precision\"..\n    // ie 1.44999 @ 3dp = (1.44999 + 0.001).toString().substr(0,5)\n    rightOperand.n_value[rightOperand.n_len + rightOperand.n_scale - 1] = 1\n    if (temp.n_sign === libbcmath.MINUS) {\n      // round down\n      rightOperand.n_sign = libbcmath.MINUS\n    }\n    result = libbcmath.bc_add(temp, rightOperand, precision)\n  } else {\n    // leave-as-is.. just truncate it.\n    result = temp\n  }\n\n  if (result.n_scale > precision) {\n    result.n_scale = precision\n  }\n\n  return result.toString()\n}\n"]}