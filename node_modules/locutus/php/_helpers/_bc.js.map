{"version":3,"sources":["../../../src/php/_helpers/_bc.js"],"names":["module","exports","_bc","Libbcmath","PLUS","MINUS","BASE","scale","bc_num","n_sign","n_len","n_scale","n_value","toString","r","tmp","join","substr","bc_add","n1","n2","scaleMin","sum","cmpRes","resScale","_bc_do_add","_bc_do_compare","_bc_do_sub","MAX","bc_new_num","memset","bc_compare","_one_mult","num","nPtr","size","digit","result","rPtr","carry","value","nptr","rptr","memcpy","Math","floor","bc_divide","qval","num1","num2","ptr1","ptr2","n2ptr","qptr","scale1","val","len1","len2","scale2","qdigits","extra","count","qdig","qguess","borrow","mval","zero","norm","bc_is_zero","MIN","safe_emalloc","bc_out_of_memory","_bc_rm_leading_zeros","MUL_BASE_DIGITS","MUL_SMALL_DIGITS","bc_multiply","pval","fullScale","prodScale","_bc_rec_mul","new_sub_num","length","temp","_bc_simp_mul","n1len","n2len","prod","n1ptr","pvptr","n1end","n2end","indx","prodlen","_bc_shift_addsub","accum","shift","sub","accp","valp","Error","u","ulen","v","vlen","u0","u1","v0","v1","m1","m2","m3","d1","d2","n","m1zero","d1len","d2len","bc_init_num","bc_sub","useSign","ignoreLast","min","diff","sumScale","sumDigits","sumptr","n1bytes","n2bytes","diffScale","diffLen","minScale","minLen","diffptr","len","Array","php_str2num","str","p","indexOf","bc_str2num","CH_VAL","c","BCD_CHAR","d","isdigit","isNaN","parseInt","strIn","ptr","digits","strscale","zeroInt","split","cint","x","a","b","ODD","chr","i","dest","src","srcptr"],"mappings":"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","file":"_bc.js","sourcesContent":["module.exports = function _bc () { // eslint-disable-line camelcase\n  //  discuss at: http://locutus.io/php/_helpers/_bc\n  // original by: lmeyrick (https://sourceforge.net/projects/bcmath-js/)\n  // improved by: Brett Zamir (http://brett-zamir.me)\n  //   example 1: var $bc = _bc()\n  //   example 1: var $result = $bc.PLUS\n  //   returns 1: '+'\n\n  /**\n   * BC Math Library for Javascript\n   * Ported from the PHP5 bcmath extension source code,\n   * which uses the Libbcmath package...\n   *    Copyright (C) 1991, 1992, 1993, 1994, 1997 Free Software Foundation, Inc.\n   *    Copyright (C) 2000 Philip A. Nelson\n   *     The Free Software Foundation, Inc.\n   *     59 Temple Place, Suite 330\n   *     Boston, MA 02111-1307 USA.\n   *      e-mail:  philnelson@acm.org\n   *     us-mail:  Philip A. Nelson\n   *               Computer Science Department, 9062\n   *               Western Washington University\n   *               Bellingham, WA 98226-9062\n   *\n   * bcmath-js homepage:\n   *\n   * This code is covered under the LGPL licence, and can be used however you want :)\n   * Be kind and share any decent code changes.\n   */\n\n  /**\n   * Binary Calculator (BC) Arbitrary Precision Mathematics Lib v0.10  (LGPL)\n   * Copy of Libbcmath included in PHP5 src\n   *\n   * Note: this is just the shared library file and does not include the php-style functions.\n   *       use bcmath{-min}.js for functions like bcadd, bcsub etc.\n   *\n   * Feel free to use how-ever you want, just email any bug-fixes/improvements\n   * to the sourceforge project:\n   *\n   *\n   * Ported from the PHP5 bcmath extension source code,\n   * which uses the Libbcmath package...\n   *    Copyright (C) 1991, 1992, 1993, 1994, 1997 Free Software Foundation, Inc.\n   *    Copyright (C) 2000 Philip A. Nelson\n   *     The Free Software Foundation, Inc.\n   *     59 Temple Place, Suite 330\n   *     Boston, MA 02111-1307 USA.\n   *      e-mail:  philnelson@acm.org\n   *     us-mail:  Philip A. Nelson\n   *               Computer Science Department, 9062\n   *               Western Washington University\n   *               Bellingham, WA 98226-9062\n   */\n\n  var Libbcmath = {\n    PLUS: '+',\n    MINUS: '-',\n    BASE: 10,\n    // must be 10 (for now)\n    scale: 0,\n    // default scale\n    /**\n     * Basic number structure\n     */\n    bc_num: function () {\n      this.n_sign = null // sign\n      this.n_len = null // (int) The number of digits before the decimal point.\n      this.n_scale = null // (int) The number of digits after the decimal point.\n        // this.n_refs = null; // (int) The number of pointers to this number.\n        // this.n_text = null; // ?? Linked list for available list.\n      this.n_value = null // array as value, where 1.23 = [1,2,3]\n      this.toString = function () {\n        var r, tmp\n        tmp = this.n_value.join('')\n\n        // add minus sign (if applicable) then add the integer part\n        r = ((this.n_sign === Libbcmath.PLUS) ? '' : this.n_sign) + tmp.substr(0, this.n_len)\n\n        // if decimal places, add a . and the decimal part\n        if (this.n_scale > 0) {\n          r += '.' + tmp.substr(this.n_len, this.n_scale)\n        }\n        return r\n      }\n    },\n\n    /**\n     * Base add function\n     *\n     //  Here is the full add routine that takes care of negative numbers.\n     //  N1 is added to N2 and the result placed into RESULT.  SCALE_MIN\n     //  is the minimum scale for the result.\n     *\n     * @param {bc_num} n1\n     * @param {bc_num} n2\n     * @param {int} scaleMin\n     * @return bc_num\n     */\n    bc_add: function (n1, n2, scaleMin) {\n      var sum, cmpRes, resScale\n\n      if (n1.n_sign === n2.n_sign) {\n        sum = Libbcmath._bc_do_add(n1, n2, scaleMin)\n        sum.n_sign = n1.n_sign\n      } else { // subtraction must be done.\n        cmpRes = Libbcmath._bc_do_compare(n1, n2, false, false) // Compare magnitudes.\n        switch (cmpRes) {\n          case -1:\n            // n1 is less than n2, subtract n1 from n2.\n            sum = Libbcmath._bc_do_sub(n2, n1, scaleMin)\n            sum.n_sign = n2.n_sign\n            break\n\n          case 0:\n            // They are equal! return zero with the correct scale!\n            resScale = Libbcmath.MAX(scaleMin, Libbcmath.MAX(n1.n_scale, n2.n_scale))\n            sum = Libbcmath.bc_new_num(1, resScale)\n            Libbcmath.memset(sum.n_value, 0, 0, resScale + 1)\n            break\n\n          case 1:\n            // n2 is less than n1, subtract n2 from n1.\n            sum = Libbcmath._bc_do_sub(n1, n2, scaleMin)\n            sum.n_sign = n1.n_sign\n        }\n      }\n      return sum\n    },\n\n    /**\n     * This is the \"user callable\" routine to compare numbers N1 and N2.\n     * @param {bc_num} n1\n     * @param {bc_num} n2\n     * @return int -1, 0, 1  (n1 < n2, ===, n1 > n2)\n     */\n    bc_compare: function (n1, n2) {\n      return Libbcmath._bc_do_compare(n1, n2, true, false)\n    },\n\n    _one_mult: function (num, nPtr, size, digit, result, rPtr) {\n      var carry, value // int\n      var nptr, rptr // int pointers\n      if (digit === 0) {\n        Libbcmath.memset(result, 0, 0, size) // memset (result, 0, size);\n      } else {\n        if (digit === 1) {\n          Libbcmath.memcpy(result, rPtr, num, nPtr, size) // memcpy (result, num, size);\n        } else { // Initialize\n          nptr = nPtr + size - 1 // nptr = (unsigned char *) (num+size-1);\n          rptr = rPtr + size - 1 // rptr = (unsigned char *) (result+size-1);\n          carry = 0\n\n          while (size-- > 0) {\n            value = num[nptr--] * digit + carry // value = *nptr-- * digit + carry;\n            result[rptr--] = value % Libbcmath.BASE // @CHECK cint //*rptr-- = value % BASE;\n            carry = Math.floor(value / Libbcmath.BASE) // @CHECK cint //carry = value / BASE;\n          }\n\n          if (carry !== 0) {\n            result[rptr] = carry\n          }\n        }\n      }\n    },\n\n    bc_divide: function (n1, n2, scale) {\n      // var quot // bc_num return\n      var qval // bc_num\n      var num1, num2 // string\n      var ptr1, ptr2, n2ptr, qptr // int pointers\n      var scale1, val // int\n      var len1, len2, scale2, qdigits, extra, count // int\n      var qdig, qguess, borrow, carry // int\n      var mval // string\n      var zero // char\n      var norm // int\n      // var ptrs // return object from one_mul\n      // Test for divide by zero. (return failure)\n      if (Libbcmath.bc_is_zero(n2)) {\n        return -1\n      }\n\n      // Test for zero divide by anything (return zero)\n      if (Libbcmath.bc_is_zero(n1)) {\n        return Libbcmath.bc_new_num(1, scale)\n      }\n\n      /* Test for n1 equals n2 (return 1 as n1 nor n2 are zero)\n        if (Libbcmath.bc_compare(n1, n2, Libbcmath.MAX(n1.n_scale, n2.n_scale)) === 0) {\n          quot=Libbcmath.bc_new_num(1, scale);\n          quot.n_value[0] = 1;\n          return quot;\n        }\n      */\n\n      // Test for divide by 1.  If it is we must truncate.\n      // @todo: check where scale > 0 too.. can't see why not\n      // (ie bc_is_zero - add bc_is_one function)\n      if (n2.n_scale === 0) {\n        if (n2.n_len === 1 && n2.n_value[0] === 1) {\n          qval = Libbcmath.bc_new_num(n1.n_len, scale) // qval = bc_new_num (n1->n_len, scale);\n          qval.n_sign = (n1.n_sign === n2.n_sign ? Libbcmath.PLUS : Libbcmath.MINUS)\n          // memset (&qval->n_value[n1->n_len],0,scale):\n          Libbcmath.memset(qval.n_value, n1.n_len, 0, scale)\n          // memcpy (qval->n_value, n1->n_value, n1->n_len + MIN(n1->n_scale,scale)):\n          Libbcmath.memcpy(\n            qval.n_value, 0, n1.n_value, 0, n1.n_len + Libbcmath.MIN(n1.n_scale, scale)\n          )\n          // can we return here? not in c src, but can't see why-not.\n          // return qval;\n        }\n      }\n\n      /* Set up the divide.  Move the decimal point on n1 by n2's scale.\n       Remember, zeros on the end of num2 are wasted effort for dividing. */\n      scale2 = n2.n_scale // scale2 = n2->n_scale;\n      n2ptr = n2.n_len + scale2 - 1 // n2ptr = (unsigned char *) n2.n_value+n2.n_len+scale2-1;\n      while ((scale2 > 0) && (n2.n_value[n2ptr--] === 0)) {\n        scale2--\n      }\n\n      len1 = n1.n_len + scale2\n      scale1 = n1.n_scale - scale2\n      if (scale1 < scale) {\n        extra = scale - scale1\n      } else {\n        extra = 0\n      }\n\n      // num1 = (unsigned char *) safe_emalloc (1, n1.n_len+n1.n_scale, extra+2):\n      num1 = Libbcmath.safe_emalloc(1, n1.n_len + n1.n_scale, extra + 2)\n      if (num1 === null) {\n        Libbcmath.bc_out_of_memory()\n      }\n      // memset (num1, 0, n1->n_len+n1->n_scale+extra+2):\n      Libbcmath.memset(num1, 0, 0, n1.n_len + n1.n_scale + extra + 2)\n      // memcpy (num1+1, n1.n_value, n1.n_len+n1.n_scale):\n      Libbcmath.memcpy(num1, 1, n1.n_value, 0, n1.n_len + n1.n_scale)\n      // len2 = n2->n_len + scale2:\n      len2 = n2.n_len + scale2\n      // num2 = (unsigned char *) safe_emalloc (1, len2, 1):\n      num2 = Libbcmath.safe_emalloc(1, len2, 1)\n      if (num2 === null) {\n        Libbcmath.bc_out_of_memory()\n      }\n      // memcpy (num2, n2.n_value, len2):\n      Libbcmath.memcpy(num2, 0, n2.n_value, 0, len2)\n      // *(num2+len2) = 0:\n      num2[len2] = 0\n      // n2ptr = num2:\n      n2ptr = 0\n      // while (*n2ptr === 0):\n      while (num2[n2ptr] === 0) {\n        n2ptr++\n        len2--\n      }\n\n      // Calculate the number of quotient digits.\n      if (len2 > len1 + scale) {\n        qdigits = scale + 1\n        zero = true\n      } else {\n        zero = false\n        if (len2 > len1) {\n          qdigits = scale + 1 // One for the zero integer part.\n        } else {\n          qdigits = len1 - len2 + scale + 1\n        }\n      }\n\n      // Allocate and zero the storage for the quotient.\n      // qval = bc_new_num (qdigits-scale,scale);\n      qval = Libbcmath.bc_new_num(qdigits - scale, scale)\n      // memset (qval->n_value, 0, qdigits);\n      Libbcmath.memset(qval.n_value, 0, 0, qdigits)\n        // Allocate storage for the temporary storage mval.\n      // mval = (unsigned char *) safe_emalloc (1, len2, 1);\n      mval = Libbcmath.safe_emalloc(1, len2, 1)\n      if (mval === null) {\n        Libbcmath.bc_out_of_memory()\n      }\n\n      // Now for the full divide algorithm.\n      if (!zero) { // Normalize\n        // norm = Libbcmath.cint(10 / (Libbcmath.cint(n2.n_value[n2ptr]) + 1));\n        // norm =  10 / ((int)*n2ptr + 1)\n        norm = Math.floor(10 / (n2.n_value[n2ptr] + 1)) // norm =  10 / ((int)*n2ptr + 1);\n        if (norm !== 1) {\n          // Libbcmath._one_mult(num1, len1+scale1+extra+1, norm, num1);\n          Libbcmath._one_mult(num1, 0, len1 + scale1 + extra + 1, norm, num1, 0)\n          // Libbcmath._one_mult(n2ptr, len2, norm, n2ptr);\n          Libbcmath._one_mult(n2.n_value, n2ptr, len2, norm, n2.n_value, n2ptr)\n          // @todo: Check: Is the pointer affected by the call? if so,\n          // maybe need to adjust points on return?\n        }\n\n        // Initialize divide loop.\n        qdig = 0\n        if (len2 > len1) {\n          qptr = len2 - len1 // qptr = (unsigned char *) qval.n_value+len2-len1;\n        } else {\n          qptr = 0 // qptr = (unsigned char *) qval.n_value;\n        }\n\n        // Loop\n        while (qdig <= len1 + scale - len2) { // Calculate the quotient digit guess.\n          if (n2.n_value[n2ptr] === num1[qdig]) {\n            qguess = 9\n          } else {\n            qguess = Math.floor((num1[qdig] * 10 + num1[qdig + 1]) / n2.n_value[n2ptr])\n          }\n          // Test qguess.\n\n          if (n2.n_value[n2ptr + 1] * qguess >\n            (num1[qdig] * 10 + num1[qdig + 1] - n2.n_value[n2ptr] * qguess) *\n            10 + num1[qdig + 2]) {\n            qguess--\n            // And again.\n            if (n2.n_value[n2ptr + 1] * qguess >\n              (num1[qdig] * 10 + num1[qdig + 1] - n2.n_value[n2ptr] * qguess) *\n              10 + num1[qdig + 2]) {\n              qguess--\n            }\n          }\n\n          // Multiply and subtract.\n          borrow = 0\n          if (qguess !== 0) {\n            mval[0] = 0 //* mval = 0; // @CHECK is this to fix ptr2 < 0?\n            // _one_mult (n2ptr, len2, qguess, mval+1); // @CHECK\n            Libbcmath._one_mult(n2.n_value, n2ptr, len2, qguess, mval, 1)\n            ptr1 = qdig + len2 // (unsigned char *) num1+qdig+len2;\n            ptr2 = len2 // (unsigned char *) mval+len2;\n            // @todo: CHECK: Does a negative pointer return null?\n            // ptr2 can be < 0 here as ptr1 = len2, thus count < len2+1 will always fail ?\n            for (count = 0; count < len2 + 1; count++) {\n              if (ptr2 < 0) {\n                // val = Libbcmath.cint(num1[ptr1]) - 0 - borrow;\n                // val = (int) *ptr1 - (int) *ptr2-- - borrow;\n                val = num1[ptr1] - 0 - borrow // val = (int) *ptr1 - (int) *ptr2-- - borrow;\n              } else {\n                // val = Libbcmath.cint(num1[ptr1]) - Libbcmath.cint(mval[ptr2--]) - borrow;\n                // val = (int) *ptr1 - (int) *ptr2-- - borrow;\n                // val = (int) *ptr1 - (int) *ptr2-- - borrow;\n                val = num1[ptr1] - mval[ptr2--] - borrow\n              }\n              if (val < 0) {\n                val += 10\n                borrow = 1\n              } else {\n                borrow = 0\n              }\n              num1[ptr1--] = val\n            }\n          }\n\n          // Test for negative result.\n          if (borrow === 1) {\n            qguess--\n            ptr1 = qdig + len2 // (unsigned char *) num1+qdig+len2;\n            ptr2 = len2 - 1 // (unsigned char *) n2ptr+len2-1;\n            carry = 0\n            for (count = 0; count < len2; count++) {\n              if (ptr2 < 0) {\n                // val = Libbcmath.cint(num1[ptr1]) + 0 + carry;\n                // val = (int) *ptr1 + (int) *ptr2-- + carry;\n                // val = (int) *ptr1 + (int) *ptr2-- + carry;\n                val = num1[ptr1] + 0 + carry\n              } else {\n                // val = Libbcmath.cint(num1[ptr1]) + Libbcmath.cint(n2.n_value[ptr2--]) + carry;\n                // val = (int) *ptr1 + (int) *ptr2-- + carry;\n                // val = (int) *ptr1 + (int) *ptr2-- + carry;\n                val = num1[ptr1] + n2.n_value[ptr2--] + carry\n              }\n              if (val > 9) {\n                val -= 10\n                carry = 1\n              } else {\n                carry = 0\n              }\n              num1[ptr1--] = val //* ptr1-- = val;\n            }\n            if (carry === 1) {\n              // num1[ptr1] = Libbcmath.cint((num1[ptr1] + 1) % 10);\n              // *ptr1 = (*ptr1 + 1) % 10; // @CHECK\n              // *ptr1 = (*ptr1 + 1) % 10; // @CHECK\n              num1[ptr1] = (num1[ptr1] + 1) % 10\n            }\n          }\n\n          // We now know the quotient digit.\n          qval.n_value[qptr++] = qguess //* qptr++ =  qguess;\n          qdig++\n        }\n      }\n\n      // Clean up and return the number.\n      qval.n_sign = (n1.n_sign === n2.n_sign ? Libbcmath.PLUS : Libbcmath.MINUS)\n      if (Libbcmath.bc_is_zero(qval)) {\n        qval.n_sign = Libbcmath.PLUS\n      }\n      Libbcmath._bc_rm_leading_zeros(qval)\n\n      return qval\n\n      // return 0;    // Everything is OK.\n    },\n\n    MUL_BASE_DIGITS: 80,\n    MUL_SMALL_DIGITS: (80 / 4),\n    // #define MUL_SMALL_DIGITS mul_base_digits/4\n\n    /* The multiply routine.  N2 times N1 is put int PROD with the scale of\n   the result being MIN(N2 scale+N1 scale, MAX (SCALE, N2 scale, N1 scale)).\n   */\n    /**\n     * @param n1 bc_num\n     * @param n2 bc_num\n     * @param scale [int] optional\n     */\n    bc_multiply: function (n1, n2, scale) {\n      var pval // bc_num\n      var len1, len2 // int\n      var fullScale, prodScale // int\n        // Initialize things.\n      len1 = n1.n_len + n1.n_scale\n      len2 = n2.n_len + n2.n_scale\n      fullScale = n1.n_scale + n2.n_scale\n      prodScale = Libbcmath.MIN(\n        fullScale, Libbcmath.MAX(scale, Libbcmath.MAX(n1.n_scale, n2.n_scale))\n      )\n\n      // pval = Libbcmath.bc_init_num(); // allow pass by ref\n      // Do the multiply\n      pval = Libbcmath._bc_rec_mul(n1, len1, n2, len2, fullScale)\n\n      // Assign to prod and clean up the number.\n      pval.n_sign = (n1.n_sign === n2.n_sign ? Libbcmath.PLUS : Libbcmath.MINUS)\n        // pval.n_value = pval.nPtr;\n      pval.n_len = len2 + len1 + 1 - fullScale\n      pval.n_scale = prodScale\n      Libbcmath._bc_rm_leading_zeros(pval)\n      if (Libbcmath.bc_is_zero(pval)) {\n        pval.n_sign = Libbcmath.PLUS\n      }\n      // bc_free_num (prod);\n      return pval\n    },\n\n    new_sub_num: function (length, scale, value) {\n      var temp = new Libbcmath.bc_num() // eslint-disable-line new-cap\n      temp.n_sign = Libbcmath.PLUS\n      temp.n_len = length\n      temp.n_scale = scale\n      temp.n_value = value\n      return temp\n    },\n\n    _bc_simp_mul: function (n1, n1len, n2, n2len, fullScale) {\n      var prod // bc_num\n      var n1ptr, n2ptr, pvptr // char *n1ptr, *n2ptr, *pvptr;\n      var n1end, n2end // char *n1end, *n2end;        // To the end of n1 and n2.\n      var indx, sum, prodlen // int indx, sum, prodlen;\n      prodlen = n1len + n2len + 1\n\n      prod = Libbcmath.bc_new_num(prodlen, 0)\n\n      n1end = n1len - 1 // (char *) (n1->n_value + n1len - 1);\n      n2end = n2len - 1 // (char *) (n2->n_value + n2len - 1);\n      pvptr = prodlen - 1 // (char *) ((*prod)->n_value + prodlen - 1);\n      sum = 0\n\n      // Here is the loop...\n      for (indx = 0; indx < prodlen - 1; indx++) {\n        // (char *) (n1end - MAX(0, indx-n2len+1));\n        n1ptr = n1end - Libbcmath.MAX(0, indx - n2len + 1)\n        // (char *) (n2end - MIN(indx, n2len-1));\n        n2ptr = n2end - Libbcmath.MIN(indx, n2len - 1)\n        while ((n1ptr >= 0) && (n2ptr <= n2end)) {\n          // sum += *n1ptr-- * *n2ptr++;\n          sum += n1.n_value[n1ptr--] * n2.n_value[n2ptr++]\n        }\n        //* pvptr-- = sum % BASE;\n        prod.n_value[pvptr--] = Math.floor(sum % Libbcmath.BASE)\n        sum = Math.floor(sum / Libbcmath.BASE) // sum = sum / BASE;\n      }\n      prod.n_value[pvptr] = sum //* pvptr = sum;\n      return prod\n    },\n\n    /* A special adder/subtractor for the recursive divide and conquer\n       multiply algorithm.  Note: if sub is called, accum must\n       be larger that what is being subtracted.  Also, accum and val\n       must have n_scale = 0.  (e.g. they must look like integers. *) */\n    _bc_shift_addsub: function (accum, val, shift, sub) {\n      var accp, valp // signed char *accp, *valp;\n      var count, carry // int  count, carry;\n      count = val.n_len\n      if (val.n_value[0] === 0) {\n        count--\n      }\n\n      // assert (accum->n_len+accum->n_scale >= shift+count);\n      if (accum.n_len + accum.n_scale < shift + count) {\n        throw new Error('len + scale < shift + count') // ?? I think that's what assert does :)\n      }\n\n      // Set up pointers and others\n      // (signed char *)(accum->n_value + accum->n_len + accum->n_scale - shift - 1);\n      accp = accum.n_len + accum.n_scale - shift - 1\n      valp = val.n_len = 1 // (signed char *)(val->n_value + val->n_len - 1);\n      carry = 0\n      if (sub) {\n        // Subtraction, carry is really borrow.\n        while (count--) {\n          accum.n_value[accp] -= val.n_value[valp--] + carry //* accp -= *valp-- + carry;\n          if (accum.n_value[accp] < 0) { // if (*accp < 0)\n            carry = 1\n            accum.n_value[accp--] += Libbcmath.BASE //* accp-- += BASE;\n          } else {\n            carry = 0\n            accp--\n          }\n        }\n        while (carry) {\n          accum.n_value[accp] -= carry //* accp -= carry;\n          if (accum.n_value[accp] < 0) { // if (*accp < 0)\n            accum.n_value[accp--] += Libbcmath.BASE //    *accp-- += BASE;\n          } else {\n            carry = 0\n          }\n        }\n      } else {\n        // Addition\n        while (count--) {\n          accum.n_value[accp] += val.n_value[valp--] + carry //* accp += *valp-- + carry;\n          if (accum.n_value[accp] > (Libbcmath.BASE - 1)) { // if (*accp > (BASE-1))\n            carry = 1\n            accum.n_value[accp--] -= Libbcmath.BASE //* accp-- -= BASE;\n          } else {\n            carry = 0\n            accp--\n          }\n        }\n        while (carry) {\n          accum.n_value[accp] += carry //* accp += carry;\n          if (accum.n_value[accp] > (Libbcmath.BASE - 1)) { // if (*accp > (BASE-1))\n            accum.n_value[accp--] -= Libbcmath.BASE //* accp-- -= BASE;\n          } else {\n            carry = 0\n          }\n        }\n      }\n      return true // accum is the pass-by-reference return\n    },\n\n    /* Recursive divide and conquer multiply algorithm.\n       based on\n       Let u = u0 + u1*(b^n)\n       Let v = v0 + v1*(b^n)\n       Then uv = (B^2n+B^n)*u1*v1 + B^n*(u1-u0)*(v0-v1) + (B^n+1)*u0*v0\n\n       B is the base of storage, number of digits in u1,u0 close to equal.\n    */\n    _bc_rec_mul: function (u, ulen, v, vlen, fullScale) {\n      var prod // @return\n      var u0, u1, v0, v1 // bc_num\n      // var u0len,\n      // var v0len // int\n      var m1, m2, m3, d1, d2 // bc_num\n      var n, prodlen, m1zero // int\n      var d1len, d2len // int\n        // Base case?\n      if ((ulen + vlen) < Libbcmath.MUL_BASE_DIGITS ||\n        ulen < Libbcmath.MUL_SMALL_DIGITS ||\n        vlen < Libbcmath.MUL_SMALL_DIGITS) {\n        return Libbcmath._bc_simp_mul(u, ulen, v, vlen, fullScale)\n      }\n\n      // Calculate n -- the u and v split point in digits.\n      n = Math.floor((Libbcmath.MAX(ulen, vlen) + 1) / 2)\n\n      // Split u and v.\n      if (ulen < n) {\n        u1 = Libbcmath.bc_init_num() // u1 = bc_copy_num (BCG(_zero_));\n        u0 = Libbcmath.new_sub_num(ulen, 0, u.n_value)\n      } else {\n        u1 = Libbcmath.new_sub_num(ulen - n, 0, u.n_value)\n        u0 = Libbcmath.new_sub_num(n, 0, u.n_value + ulen - n)\n      }\n      if (vlen < n) {\n        v1 = Libbcmath.bc_init_num() // bc_copy_num (BCG(_zero_));\n        v0 = Libbcmath.new_sub_num(vlen, 0, v.n_value)\n      } else {\n        v1 = Libbcmath.new_sub_num(vlen - n, 0, v.n_value)\n        v0 = Libbcmath.new_sub_num(n, 0, v.n_value + vlen - n)\n      }\n      Libbcmath._bc_rm_leading_zeros(u1)\n      Libbcmath._bc_rm_leading_zeros(u0)\n      // var u0len = u0.n_len\n      Libbcmath._bc_rm_leading_zeros(v1)\n      Libbcmath._bc_rm_leading_zeros(v0)\n      // var v0len = v0.n_len\n\n      m1zero = Libbcmath.bc_is_zero(u1) || Libbcmath.bc_is_zero(v1)\n\n      // Calculate sub results ...\n      d1 = Libbcmath.bc_init_num() // needed?\n      d2 = Libbcmath.bc_init_num() // needed?\n      d1 = Libbcmath.bc_sub(u1, u0, 0)\n      d1len = d1.n_len\n\n      d2 = Libbcmath.bc_sub(v0, v1, 0)\n      d2len = d2.n_len\n\n      // Do recursive multiplies and shifted adds.\n      if (m1zero) {\n        m1 = Libbcmath.bc_init_num() // bc_copy_num (BCG(_zero_));\n      } else {\n        // m1 = Libbcmath.bc_init_num(); //allow pass-by-ref\n        m1 = Libbcmath._bc_rec_mul(u1, u1.n_len, v1, v1.n_len, 0)\n      }\n      if (Libbcmath.bc_is_zero(d1) || Libbcmath.bc_is_zero(d2)) {\n        m2 = Libbcmath.bc_init_num() // bc_copy_num (BCG(_zero_));\n      } else {\n        // m2 = Libbcmath.bc_init_num(); //allow pass-by-ref\n        m2 = Libbcmath._bc_rec_mul(d1, d1len, d2, d2len, 0)\n      }\n\n      if (Libbcmath.bc_is_zero(u0) || Libbcmath.bc_is_zero(v0)) {\n        m3 = Libbcmath.bc_init_num() // bc_copy_num (BCG(_zero_));\n      } else {\n        // m3 = Libbcmath.bc_init_num(); //allow pass-by-ref\n        m3 = Libbcmath._bc_rec_mul(u0, u0.n_len, v0, v0.n_len, 0)\n      }\n\n      // Initialize product\n      prodlen = ulen + vlen + 1\n      prod = Libbcmath.bc_new_num(prodlen, 0)\n\n      if (!m1zero) {\n        Libbcmath._bc_shift_addsub(prod, m1, 2 * n, 0)\n        Libbcmath._bc_shift_addsub(prod, m1, n, 0)\n      }\n      Libbcmath._bc_shift_addsub(prod, m3, n, 0)\n      Libbcmath._bc_shift_addsub(prod, m3, 0, 0)\n      Libbcmath._bc_shift_addsub(prod, m2, n, d1.n_sign !== d2.n_sign)\n\n      return prod\n        // Now clean up!\n        // bc_free_num (&u1);\n        // bc_free_num (&u0);\n        // bc_free_num (&v1);\n        // bc_free_num (&m1);\n        // bc_free_num (&v0);\n        // bc_free_num (&m2);\n        // bc_free_num (&m3);\n        // bc_free_num (&d1);\n        // bc_free_num (&d2);\n    },\n\n    /**\n     *\n     * @param {bc_num} n1\n     * @param {bc_num} n2\n     * @param {boolean} useSign\n     * @param {boolean} ignoreLast\n     * @return -1, 0, 1 (see bc_compare)\n     */\n    _bc_do_compare: function (n1, n2, useSign, ignoreLast) {\n      var n1ptr, n2ptr // int\n      var count // int\n        // First, compare signs.\n      if (useSign && (n1.n_sign !== n2.n_sign)) {\n        if (n1.n_sign === Libbcmath.PLUS) {\n          return (1) // Positive N1 > Negative N2\n        } else {\n          return (-1) // Negative N1 < Positive N1\n        }\n      }\n\n      // Now compare the magnitude.\n      if (n1.n_len !== n2.n_len) {\n        if (n1.n_len > n2.n_len) { // Magnitude of n1 > n2.\n          if (!useSign || (n1.n_sign === Libbcmath.PLUS)) {\n            return (1)\n          } else {\n            return (-1)\n          }\n        } else { // Magnitude of n1 < n2.\n          if (!useSign || (n1.n_sign === Libbcmath.PLUS)) {\n            return (-1)\n          } else {\n            return (1)\n          }\n        }\n      }\n\n      /* If we get here, they have the same number of integer digits.\n     check the integer part and the equal length part of the fraction. */\n      count = n1.n_len + Math.min(n1.n_scale, n2.n_scale)\n      n1ptr = 0\n      n2ptr = 0\n\n      while ((count > 0) && (n1.n_value[n1ptr] === n2.n_value[n2ptr])) {\n        n1ptr++\n        n2ptr++\n        count--\n      }\n\n      if (ignoreLast && (count === 1) && (n1.n_scale === n2.n_scale)) {\n        return (0)\n      }\n\n      if (count !== 0) {\n        if (n1.n_value[n1ptr] > n2.n_value[n2ptr]) { // Magnitude of n1 > n2.\n          if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n            return (1)\n          } else {\n            return (-1)\n          }\n        } else { // Magnitude of n1 < n2.\n          if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n            return (-1)\n          } else {\n            return (1)\n          }\n        }\n      }\n\n      // They are equal up to the last part of the equal part of the fraction.\n      if (n1.n_scale !== n2.n_scale) {\n        if (n1.n_scale > n2.n_scale) {\n          for (count = (n1.n_scale - n2.n_scale); count > 0; count--) {\n            if (n1.n_value[n1ptr++] !== 0) { // Magnitude of n1 > n2.\n              if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n                return (1)\n              } else {\n                return (-1)\n              }\n            }\n          }\n        } else {\n          for (count = (n2.n_scale - n1.n_scale); count > 0; count--) {\n            if (n2.n_value[n2ptr++] !== 0) { // Magnitude of n1 < n2.\n              if (!useSign || n1.n_sign === Libbcmath.PLUS) {\n                return (-1)\n              } else {\n                return (1)\n              }\n            }\n          }\n        }\n      }\n\n      // They must be equal!\n      return (0)\n    },\n\n    /* Here is the full subtract routine that takes care of negative numbers.\n   N2 is subtracted from N1 and the result placed in RESULT.  SCALE_MIN\n   is the minimum scale for the result. */\n    bc_sub: function (n1, n2, scaleMin) {\n      var diff // bc_num\n      var cmpRes, resScale // int\n      if (n1.n_sign !== n2.n_sign) {\n        diff = Libbcmath._bc_do_add(n1, n2, scaleMin)\n        diff.n_sign = n1.n_sign\n      } else { // subtraction must be done.\n        // Compare magnitudes.\n        cmpRes = Libbcmath._bc_do_compare(n1, n2, false, false)\n        switch (cmpRes) {\n          case -1:\n            // n1 is less than n2, subtract n1 from n2.\n            diff = Libbcmath._bc_do_sub(n2, n1, scaleMin)\n            diff.n_sign = (n2.n_sign === Libbcmath.PLUS ? Libbcmath.MINUS : Libbcmath.PLUS)\n            break\n          case 0:\n            // They are equal! return zero!\n            resScale = Libbcmath.MAX(scaleMin, Libbcmath.MAX(n1.n_scale, n2.n_scale))\n            diff = Libbcmath.bc_new_num(1, resScale)\n            Libbcmath.memset(diff.n_value, 0, 0, resScale + 1)\n            break\n          case 1:\n            // n2 is less than n1, subtract n2 from n1.\n            diff = Libbcmath._bc_do_sub(n1, n2, scaleMin)\n            diff.n_sign = n1.n_sign\n            break\n        }\n      }\n\n      // Clean up and return.\n      // bc_free_num (result);\n      //* result = diff;\n      return diff\n    },\n\n    _bc_do_add: function (n1, n2, scaleMin) {\n      var sum // bc_num\n      var sumScale, sumDigits // int\n      var n1ptr, n2ptr, sumptr // int\n      var carry, n1bytes, n2bytes // int\n      var tmp // int\n\n      // Prepare sum.\n      sumScale = Libbcmath.MAX(n1.n_scale, n2.n_scale)\n      sumDigits = Libbcmath.MAX(n1.n_len, n2.n_len) + 1\n      sum = Libbcmath.bc_new_num(sumDigits, Libbcmath.MAX(sumScale, scaleMin))\n\n      // Start with the fraction part.  Initialize the pointers.\n      n1bytes = n1.n_scale\n      n2bytes = n2.n_scale\n      n1ptr = (n1.n_len + n1bytes - 1)\n      n2ptr = (n2.n_len + n2bytes - 1)\n      sumptr = (sumScale + sumDigits - 1)\n\n      // Add the fraction part.  First copy the longer fraction\n      // (ie when adding 1.2345 to 1 we know .2345 is correct already) .\n      if (n1bytes !== n2bytes) {\n        if (n1bytes > n2bytes) {\n          // n1 has more dp then n2\n          while (n1bytes > n2bytes) {\n            sum.n_value[sumptr--] = n1.n_value[n1ptr--]\n              // *sumptr-- = *n1ptr--;\n            n1bytes--\n          }\n        } else {\n          // n2 has more dp then n1\n          while (n2bytes > n1bytes) {\n            sum.n_value[sumptr--] = n2.n_value[n2ptr--]\n              // *sumptr-- = *n2ptr--;\n            n2bytes--\n          }\n        }\n      }\n\n      // Now add the remaining fraction part and equal size integer parts.\n      n1bytes += n1.n_len\n      n2bytes += n2.n_len\n      carry = 0\n      while ((n1bytes > 0) && (n2bytes > 0)) {\n        // add the two numbers together\n        tmp = n1.n_value[n1ptr--] + n2.n_value[n2ptr--] + carry\n          // *sumptr = *n1ptr-- + *n2ptr-- + carry;\n          // check if they are >= 10 (impossible to be more then 18)\n        if (tmp >= Libbcmath.BASE) {\n          carry = 1\n          tmp -= Libbcmath.BASE // yep, subtract 10, add a carry\n        } else {\n          carry = 0\n        }\n        sum.n_value[sumptr] = tmp\n        sumptr--\n        n1bytes--\n        n2bytes--\n      }\n\n      // Now add carry the [rest of the] longer integer part.\n      if (n1bytes === 0) {\n        // n2 is a bigger number then n1\n        while (n2bytes-- > 0) {\n          tmp = n2.n_value[n2ptr--] + carry\n            // *sumptr = *n2ptr-- + carry;\n          if (tmp >= Libbcmath.BASE) {\n            carry = 1\n            tmp -= Libbcmath.BASE\n          } else {\n            carry = 0\n          }\n          sum.n_value[sumptr--] = tmp\n        }\n      } else {\n        // n1 is bigger then n2..\n        while (n1bytes-- > 0) {\n          tmp = n1.n_value[n1ptr--] + carry\n            // *sumptr = *n1ptr-- + carry;\n          if (tmp >= Libbcmath.BASE) {\n            carry = 1\n            tmp -= Libbcmath.BASE\n          } else {\n            carry = 0\n          }\n          sum.n_value[sumptr--] = tmp\n        }\n      }\n\n      // Set final carry.\n      if (carry === 1) {\n        sum.n_value[sumptr] += 1\n          // *sumptr += 1;\n      }\n\n      // Adjust sum and return.\n      Libbcmath._bc_rm_leading_zeros(sum)\n      return sum\n    },\n\n    /**\n     * Perform a subtraction\n     *\n     * Perform subtraction: N2 is subtracted from N1 and the value is\n     *  returned.  The signs of N1 and N2 are ignored.  Also, N1 is\n     *  assumed to be larger than N2.  SCALE_MIN is the minimum scale\n     *  of the result.\n     *\n     * Basic school maths says to subtract 2 numbers..\n     * 1. make them the same length, the decimal places, and the integer part\n     * 2. start from the right and subtract the two numbers from each other\n     * 3. if the sum of the 2 numbers < 0, carry -1 to the next set and add 10\n     * (ie 18 > carry 1 becomes 8). thus 0.9 + 0.9 = 1.8\n     *\n     * @param {bc_num} n1\n     * @param {bc_num} n2\n     * @param {int} scaleMin\n     * @return bc_num\n     */\n    _bc_do_sub: function (n1, n2, scaleMin) {\n      var diff // bc_num\n      var diffScale, diffLen // int\n      var minScale, minLen // int\n      var n1ptr, n2ptr, diffptr // int\n      var borrow, count, val // int\n        // Allocate temporary storage.\n      diffLen = Libbcmath.MAX(n1.n_len, n2.n_len)\n      diffScale = Libbcmath.MAX(n1.n_scale, n2.n_scale)\n      minLen = Libbcmath.MIN(n1.n_len, n2.n_len)\n      minScale = Libbcmath.MIN(n1.n_scale, n2.n_scale)\n      diff = Libbcmath.bc_new_num(diffLen, Libbcmath.MAX(diffScale, scaleMin))\n\n      /* Not needed?\n      // Zero extra digits made by scaleMin.\n      if (scaleMin > diffScale) {\n        diffptr = (char *) (diff->n_value + diffLen + diffScale);\n        for (count = scaleMin - diffScale; count > 0; count--) {\n          *diffptr++ = 0;\n        }\n      }\n      */\n\n      // Initialize the subtract.\n      n1ptr = (n1.n_len + n1.n_scale - 1)\n      n2ptr = (n2.n_len + n2.n_scale - 1)\n      diffptr = (diffLen + diffScale - 1)\n\n      // Subtract the numbers.\n      borrow = 0\n\n      // Take care of the longer scaled number.\n      if (n1.n_scale !== minScale) {\n        // n1 has the longer scale\n        for (count = n1.n_scale - minScale; count > 0; count--) {\n          diff.n_value[diffptr--] = n1.n_value[n1ptr--]\n            // *diffptr-- = *n1ptr--;\n        }\n      } else {\n        // n2 has the longer scale\n        for (count = n2.n_scale - minScale; count > 0; count--) {\n          val = 0 - n2.n_value[n2ptr--] - borrow\n            // val = - *n2ptr-- - borrow;\n          if (val < 0) {\n            val += Libbcmath.BASE\n            borrow = 1\n          } else {\n            borrow = 0\n          }\n          diff.n_value[diffptr--] = val\n            //* diffptr-- = val;\n        }\n      }\n\n      // Now do the equal length scale and integer parts.\n      for (count = 0; count < minLen + minScale; count++) {\n        val = n1.n_value[n1ptr--] - n2.n_value[n2ptr--] - borrow\n          // val = *n1ptr-- - *n2ptr-- - borrow;\n        if (val < 0) {\n          val += Libbcmath.BASE\n          borrow = 1\n        } else {\n          borrow = 0\n        }\n        diff.n_value[diffptr--] = val\n          //* diffptr-- = val;\n      }\n\n      // If n1 has more digits then n2, we now do that subtract.\n      if (diffLen !== minLen) {\n        for (count = diffLen - minLen; count > 0; count--) {\n          val = n1.n_value[n1ptr--] - borrow\n            // val = *n1ptr-- - borrow;\n          if (val < 0) {\n            val += Libbcmath.BASE\n            borrow = 1\n          } else {\n            borrow = 0\n          }\n          diff.n_value[diffptr--] = val\n        }\n      }\n\n      // Clean up and return.\n      Libbcmath._bc_rm_leading_zeros(diff)\n      return diff\n    },\n\n    /**\n     *\n     * @param {int} length\n     * @param {int} scale\n     * @return bc_num\n     */\n    bc_new_num: function (length, scale) {\n      var temp // bc_num\n      temp = new Libbcmath.bc_num() // eslint-disable-line new-cap\n      temp.n_sign = Libbcmath.PLUS\n      temp.n_len = length\n      temp.n_scale = scale\n      temp.n_value = Libbcmath.safe_emalloc(1, length + scale, 0)\n      Libbcmath.memset(temp.n_value, 0, 0, length + scale)\n      return temp\n    },\n\n    safe_emalloc: function (size, len, extra) {\n      return Array((size * len) + extra)\n    },\n\n    /**\n     * Create a new number\n     */\n    bc_init_num: function () {\n      return new Libbcmath.bc_new_num(1, 0) // eslint-disable-line new-cap\n    },\n\n    _bc_rm_leading_zeros: function (num) {\n      // We can move n_value to point to the first non zero digit!\n      while ((num.n_value[0] === 0) && (num.n_len > 1)) {\n        num.n_value.shift()\n        num.n_len--\n      }\n    },\n\n    /**\n     * Convert to bc_num detecting scale\n     */\n    php_str2num: function (str) {\n      var p\n      p = str.indexOf('.')\n      if (p === -1) {\n        return Libbcmath.bc_str2num(str, 0)\n      } else {\n        return Libbcmath.bc_str2num(str, (str.length - p))\n      }\n    },\n\n    CH_VAL: function (c) {\n      return c - '0' // ??\n    },\n\n    BCD_CHAR: function (d) {\n      return d + '0' // ??\n    },\n\n    isdigit: function (c) {\n      return isNaN(parseInt(c, 10))\n    },\n\n    bc_str2num: function (strIn, scale) {\n      var str, num, ptr, digits, strscale, zeroInt, nptr\n        // remove any non-expected characters\n        // Check for valid number and count digits.\n\n      str = strIn.split('') // convert to array\n      ptr = 0 // str\n      digits = 0\n      strscale = 0\n      zeroInt = false\n      if ((str[ptr] === '+') || (str[ptr] === '-')) {\n        ptr++ // Sign\n      }\n      while (str[ptr] === '0') {\n        ptr++ // Skip leading zeros.\n      }\n      // while (Libbcmath.isdigit(str[ptr])) {\n      while ((str[ptr]) % 1 === 0) { // Libbcmath.isdigit(str[ptr])) {\n        ptr++\n        digits++ // digits\n      }\n\n      if (str[ptr] === '.') {\n        ptr++ // decimal point\n      }\n      // while (Libbcmath.isdigit(str[ptr])) {\n      while ((str[ptr]) % 1 === 0) { // Libbcmath.isdigit(str[ptr])) {\n        ptr++\n        strscale++ // digits\n      }\n\n      if ((str[ptr]) || (digits + strscale === 0)) {\n        // invalid number, return 0\n        return Libbcmath.bc_init_num()\n          //* num = bc_copy_num (BCG(_zero_));\n      }\n\n      // Adjust numbers and allocate storage and initialize fields.\n      strscale = Libbcmath.MIN(strscale, scale)\n      if (digits === 0) {\n        zeroInt = true\n        digits = 1\n      }\n\n      num = Libbcmath.bc_new_num(digits, strscale)\n\n      // Build the whole number.\n      ptr = 0 // str\n      if (str[ptr] === '-') {\n        num.n_sign = Libbcmath.MINUS\n          // (*num)->n_sign = MINUS;\n        ptr++\n      } else {\n        num.n_sign = Libbcmath.PLUS\n          // (*num)->n_sign = PLUS;\n        if (str[ptr] === '+') {\n          ptr++\n        }\n      }\n      while (str[ptr] === '0') {\n        ptr++ // Skip leading zeros.\n      }\n\n      nptr = 0 // (*num)->n_value;\n      if (zeroInt) {\n        num.n_value[nptr++] = 0\n        digits = 0\n      }\n      for (; digits > 0; digits--) {\n        num.n_value[nptr++] = Libbcmath.CH_VAL(str[ptr++])\n          //* nptr++ = CH_VAL(*ptr++);\n      }\n\n      // Build the fractional part.\n      if (strscale > 0) {\n        ptr++ // skip the decimal point!\n        for (; strscale > 0; strscale--) {\n          num.n_value[nptr++] = Libbcmath.CH_VAL(str[ptr++])\n        }\n      }\n\n      return num\n    },\n\n    cint: function (v) {\n      if (typeof v === 'undefined') {\n        v = 0\n      }\n      var x = parseInt(v, 10)\n      if (isNaN(x)) {\n        x = 0\n      }\n      return x\n    },\n\n    /**\n     * Basic min function\n     * @param {int} a\n     * @param {int} b\n     */\n    MIN: function (a, b) {\n      return ((a > b) ? b : a)\n    },\n\n    /**\n     * Basic max function\n     * @param {int} a\n     * @param {int} b\n     */\n    MAX: function (a, b) {\n      return ((a > b) ? a : b)\n    },\n\n    /**\n     * Basic odd function\n     * @param {int} a\n     */\n    ODD: function (a) {\n      return (a & 1)\n    },\n\n    /**\n     * replicate c function\n     * @param {array} r     return (by reference)\n     * @param {int} ptr\n     * @param {string} chr    char to fill\n     * @param {int} len       length to fill\n     */\n    memset: function (r, ptr, chr, len) {\n      var i\n      for (i = 0; i < len; i++) {\n        r[ptr + i] = chr\n      }\n    },\n\n    /**\n     * Replacement c function\n     * Obviously can't work like c does, so we've added an \"offset\"\n     * param so you could do memcpy(dest+1, src, len) as memcpy(dest, 1, src, len)\n     * Also only works on arrays\n     */\n    memcpy: function (dest, ptr, src, srcptr, len) {\n      var i\n      for (i = 0; i < len; i++) {\n        dest[ptr + i] = src[srcptr + i]\n      }\n      return true\n    },\n\n    /**\n     * Determine if the number specified is zero or not\n     * @param {bc_num} num    number to check\n     * @return boolean      true when zero, false when not zero.\n     */\n    bc_is_zero: function (num) {\n      var count // int\n      var nptr // int\n      // Quick check.\n      // if (num === BCG(_zero_)) return TRUE;\n      // Initialize\n      count = num.n_len + num.n_scale\n      nptr = 0 // num->n_value;\n      // The check\n      while ((count > 0) && (num.n_value[nptr++] === 0)) {\n        count--\n      }\n\n      if (count !== 0) {\n        return false\n      } else {\n        return true\n      }\n    },\n\n    bc_out_of_memory: function () {\n      throw new Error('(BC) Out of memory')\n    }\n  }\n  return Libbcmath\n}\n"]}