{"version":3,"sources":["../../../src/php/misc/pack.js"],"names":["module","exports","pack","format","formatPointer","argumentPointer","result","argument","i","r","instruction","quantifier","word","precisionBits","exponentBits","extraNullCount","bias","minExp","maxExp","minUnnormExp","status","exp","len","bin","signal","n","intPart","floatPart","lastBit","rounded","j","k","tmpResult","length","charAt","match","arguments","Error","String","fromCharCode","msg","parseInt","Math","pow","isNaN","parseFloat","Infinity","Array","abs","floor","key","slice","join","substring","msg2"],"mappings":"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","file":"pack.js","sourcesContent":["module.exports = function pack (format) {\n  //  discuss at: http://locutus.io/php/pack/\n  // original by: Tim de Koning (http://www.kingsquare.nl)\n  //    parts by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n  // bugfixed by: Tim de Koning (http://www.kingsquare.nl)\n  //      note 1: Float encoding by: Jonas Raoni Soares Silva\n  //      note 1: Home: http://www.kingsquare.nl/blog/12-12-2009/13507444\n  //      note 1: Feedback: phpjs-pack@kingsquare.nl\n  //      note 1: \"machine dependent byte order and size\" aren't\n  //      note 1: applicable for JavaScript; pack works as on a 32bit,\n  //      note 1: little endian machine.\n  //   example 1: pack('nvc*', 0x1234, 0x5678, 65, 66)\n  //   returns 1: '\\u00124xVAB'\n  //   example 2: pack('H4', '2345')\n  //   returns 2: '#E'\n  //   example 3: pack('H*', 'D5')\n  //   returns 3: 'Õ'\n  //   example 4: pack('d', -100.876)\n  //   returns 4: \"\\u0000\\u0000\\u0000\\u0000\\u00008YÀ\"\n  //        test: skip-1\n\n  var formatPointer = 0\n  var argumentPointer = 1\n  var result = ''\n  var argument = ''\n  var i = 0\n  var r = []\n  var instruction, quantifier, word, precisionBits, exponentBits, extraNullCount\n\n  // vars used by float encoding\n  var bias\n  var minExp\n  var maxExp\n  var minUnnormExp\n  var status\n  var exp\n  var len\n  var bin\n  var signal\n  var n\n  var intPart\n  var floatPart\n  var lastBit\n  var rounded\n  var j\n  var k\n  var tmpResult\n\n  while (formatPointer < format.length) {\n    instruction = format.charAt(formatPointer)\n    quantifier = ''\n    formatPointer++\n    while ((formatPointer < format.length) && (format.charAt(formatPointer)\n        .match(/[\\d*]/) !== null)) {\n      quantifier += format.charAt(formatPointer)\n      formatPointer++\n    }\n    if (quantifier === '') {\n      quantifier = '1'\n    }\n\n    // Now pack variables: 'quantifier' times 'instruction'\n    switch (instruction) {\n      case 'a':\n      case 'A':\n        // NUL-padded string\n        // SPACE-padded string\n        if (typeof arguments[argumentPointer] === 'undefined') {\n          throw new Error('Warning:  pack() Type ' + instruction + ': not enough arguments')\n        } else {\n          argument = String(arguments[argumentPointer])\n        }\n        if (quantifier === '*') {\n          quantifier = argument.length\n        }\n        for (i = 0; i < quantifier; i++) {\n          if (typeof argument[i] === 'undefined') {\n            if (instruction === 'a') {\n              result += String.fromCharCode(0)\n            } else {\n              result += ' '\n            }\n          } else {\n            result += argument[i]\n          }\n        }\n        argumentPointer++\n        break\n      case 'h':\n      case 'H':\n        // Hex string, low nibble first\n        // Hex string, high nibble first\n        if (typeof arguments[argumentPointer] === 'undefined') {\n          throw new Error('Warning: pack() Type ' + instruction + ': not enough arguments')\n        } else {\n          argument = arguments[argumentPointer]\n        }\n        if (quantifier === '*') {\n          quantifier = argument.length\n        }\n        if (quantifier > argument.length) {\n          var msg = 'Warning: pack() Type ' + instruction + ': not enough characters in string'\n          throw new Error(msg)\n        }\n\n        for (i = 0; i < quantifier; i += 2) {\n          // Always get per 2 bytes...\n          word = argument[i]\n          if (((i + 1) >= quantifier) || typeof argument[i + 1] === 'undefined') {\n            word += '0'\n          } else {\n            word += argument[i + 1]\n          }\n          // The fastest way to reverse?\n          if (instruction === 'h') {\n            word = word[1] + word[0]\n          }\n          result += String.fromCharCode(parseInt(word, 16))\n        }\n        argumentPointer++\n        break\n\n      case 'c':\n      case 'C':\n        // signed char\n        // unsigned char\n        // c and C is the same in pack\n        if (quantifier === '*') {\n          quantifier = arguments.length - argumentPointer\n        }\n        if (quantifier > (arguments.length - argumentPointer)) {\n          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')\n        }\n\n        for (i = 0; i < quantifier; i++) {\n          result += String.fromCharCode(arguments[argumentPointer])\n          argumentPointer++\n        }\n        break\n\n      case 's':\n      case 'S':\n      case 'v':\n        // signed short (always 16 bit, machine byte order)\n        // unsigned short (always 16 bit, machine byte order)\n        // s and S is the same in pack\n        if (quantifier === '*') {\n          quantifier = arguments.length - argumentPointer\n        }\n        if (quantifier > (arguments.length - argumentPointer)) {\n          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')\n        }\n\n        for (i = 0; i < quantifier; i++) {\n          result += String.fromCharCode(arguments[argumentPointer] & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF)\n          argumentPointer++\n        }\n        break\n\n      case 'n':\n        // unsigned short (always 16 bit, big endian byte order)\n        if (quantifier === '*') {\n          quantifier = arguments.length - argumentPointer\n        }\n        if (quantifier > (arguments.length - argumentPointer)) {\n          throw new Error('Warning: pack() Type ' + instruction + ': too few arguments')\n        }\n\n        for (i = 0; i < quantifier; i++) {\n          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] & 0xFF)\n          argumentPointer++\n        }\n        break\n\n      case 'i':\n      case 'I':\n      case 'l':\n      case 'L':\n      case 'V':\n        // signed integer (machine dependent size and byte order)\n        // unsigned integer (machine dependent size and byte order)\n        // signed long (always 32 bit, machine byte order)\n        // unsigned long (always 32 bit, machine byte order)\n        // unsigned long (always 32 bit, little endian byte order)\n        if (quantifier === '*') {\n          quantifier = arguments.length - argumentPointer\n        }\n        if (quantifier > (arguments.length - argumentPointer)) {\n          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')\n        }\n\n        for (i = 0; i < quantifier; i++) {\n          result += String.fromCharCode(arguments[argumentPointer] & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] >> 16 & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] >> 24 & 0xFF)\n          argumentPointer++\n        }\n\n        break\n      case 'N':\n        // unsigned long (always 32 bit, big endian byte order)\n        if (quantifier === '*') {\n          quantifier = arguments.length - argumentPointer\n        }\n        if (quantifier > (arguments.length - argumentPointer)) {\n          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')\n        }\n\n        for (i = 0; i < quantifier; i++) {\n          result += String.fromCharCode(arguments[argumentPointer] >> 24 & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] >> 16 & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF)\n          result += String.fromCharCode(arguments[argumentPointer] & 0xFF)\n          argumentPointer++\n        }\n        break\n\n      case 'f':\n      case 'd':\n        // float (machine dependent size and representation)\n        // double (machine dependent size and representation)\n        // version based on IEEE754\n        precisionBits = 23\n        exponentBits = 8\n        if (instruction === 'd') {\n          precisionBits = 52\n          exponentBits = 11\n        }\n\n        if (quantifier === '*') {\n          quantifier = arguments.length - argumentPointer\n        }\n        if (quantifier > (arguments.length - argumentPointer)) {\n          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')\n        }\n        for (i = 0; i < quantifier; i++) {\n          argument = arguments[argumentPointer]\n          bias = Math.pow(2, exponentBits - 1) - 1\n          minExp = -bias + 1\n          maxExp = bias\n          minUnnormExp = minExp - precisionBits\n          status = isNaN(n = parseFloat(argument)) || n === -Infinity || n === +Infinity ? n : 0\n          exp = 0\n          len = 2 * bias + 1 + precisionBits + 3\n          bin = new Array(len)\n          signal = (n = status !== 0 ? 0 : n) < 0\n          n = Math.abs(n)\n          intPart = Math.floor(n)\n          floatPart = n - intPart\n\n          for (k = len; k;) {\n            bin[--k] = 0\n          }\n          for (k = bias + 2; intPart && k;) {\n            bin[--k] = intPart % 2\n            intPart = Math.floor(intPart / 2)\n          }\n          for (k = bias + 1; floatPart > 0 && k; --floatPart) {\n            (bin[++k] = ((floatPart *= 2) >= 1) - 0)\n          }\n          for (k = -1; ++k < len && !bin[k];) {}\n\n          // @todo: Make this more readable:\n          var key = (lastBit = precisionBits - 1 +\n            (k =\n              (exp = bias + 1 - k) >= minExp &&\n              exp <= maxExp ? k + 1 : bias + 1 - (exp = minExp - 1))) + 1\n\n          if (bin[key]) {\n            if (!(rounded = bin[lastBit])) {\n              for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]) {}\n            }\n            for (j = lastBit + 1; rounded && --j >= 0;\n            (bin[j] = !bin[j] - 0) && (rounded = 0)) {}\n          }\n\n          for (k = k - 2 < 0 ? -1 : k - 3; ++k < len && !bin[k];) {}\n\n          if ((exp = bias + 1 - k) >= minExp && exp <= maxExp) {\n            ++k\n          } else {\n            if (exp < minExp) {\n              if (exp !== bias + 1 - len && exp < minUnnormExp) {\n                // \"encodeFloat::float underflow\"\n              }\n              k = bias + 1 - (exp = minExp - 1)\n            }\n          }\n\n          if (intPart || status !== 0) {\n            exp = maxExp + 1\n            k = bias + 2\n            if (status === -Infinity) {\n              signal = 1\n            } else if (isNaN(status)) {\n              bin[k] = 1\n            }\n          }\n\n          n = Math.abs(exp + bias)\n          tmpResult = ''\n\n          for (j = exponentBits + 1; --j;) {\n            tmpResult = (n % 2) + tmpResult\n            n = n >>= 1\n          }\n\n          n = 0\n          j = 0\n          k = (tmpResult = (signal ? '1' : '0') + tmpResult + (bin\n            .slice(k, k + precisionBits)\n            .join(''))\n          ).length\n          r = []\n\n          for (; k;) {\n            n += (1 << j) * tmpResult.charAt(--k)\n            if (j === 7) {\n              r[r.length] = String.fromCharCode(n)\n              n = 0\n            }\n            j = (j + 1) % 8\n          }\n\n          r[r.length] = n ? String.fromCharCode(n) : ''\n          result += r.join('')\n          argumentPointer++\n        }\n        break\n\n      case 'x':\n        // NUL byte\n        if (quantifier === '*') {\n          throw new Error('Warning: pack(): Type x: \\'*\\' ignored')\n        }\n        for (i = 0; i < quantifier; i++) {\n          result += String.fromCharCode(0)\n        }\n        break\n\n      case 'X':\n        // Back up one byte\n        if (quantifier === '*') {\n          throw new Error('Warning: pack(): Type X: \\'*\\' ignored')\n        }\n        for (i = 0; i < quantifier; i++) {\n          if (result.length === 0) {\n            throw new Error('Warning: pack(): Type X:' + ' outside of string')\n          } else {\n            result = result.substring(0, result.length - 1)\n          }\n        }\n        break\n\n      case '@':\n        // NUL-fill to absolute position\n        if (quantifier === '*') {\n          throw new Error('Warning: pack(): Type X: \\'*\\' ignored')\n        }\n        if (quantifier > result.length) {\n          extraNullCount = quantifier - result.length\n          for (i = 0; i < extraNullCount; i++) {\n            result += String.fromCharCode(0)\n          }\n        }\n        if (quantifier < result.length) {\n          result = result.substring(0, quantifier)\n        }\n        break\n\n      default:\n        throw new Error('Warning: pack() Type ' + instruction + ': unknown format code')\n    }\n  }\n  if (argumentPointer < arguments.length) {\n    var msg2 = 'Warning: pack(): ' + (arguments.length - argumentPointer) + ' arguments unused'\n    throw new Error(msg2)\n  }\n\n  return result\n}\n"]}